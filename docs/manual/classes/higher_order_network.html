<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.5.3" />
<title>pathpy.classes.higher_order_network API documentation</title>
<meta name="description" content="" />
<link href='https://cdnjs.cloudflare.com/ajax/libs/normalize/8.0.0/normalize.min.css' rel='stylesheet'>
<link href='https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/8.0.0/sanitize.min.css' rel='stylesheet'>
<link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/github.min.css" rel="stylesheet">
<style>.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{font-weight:bold}#index h4 + ul{margin-bottom:.6em}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.name small{font-weight:normal}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase;cursor:pointer}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}.admonition{padding:.1em .5em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title"><code>pathpy.classes.higher_order_network</code> module</h1>
</header>
<section id="section-intro">
<details class="source">
<summary>Source code</summary>
<pre><code class="python"># -*- coding: utf-8 -*-

#    pathpy is an OpenSource python package for the analysis of time series data
#    on networks using higher- and multi order graphical models.
#
#    Copyright (C) 2016-2018 Ingo Scholtes, ETH Zürich/Universität Zürich
#
#    This program is free software: you can redistribute it and/or modify
#    it under the terms of the GNU Affero General Public License as published
#    by the Free Software Foundation, either version 3 of the License, or
#    (at your option) any later version.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU Affero General Public License for more details.
#
#    You should have received a copy of the GNU Affero General Public License
#    along with this program. If not, see &lt;http://www.gnu.org/licenses/&gt;.
#
#    Contact the developer:
#
#    E-mail: scholtes@ifi.uzh.ch
#    Web:    http://www.ingoscholtes.net

from collections import defaultdict
import numpy as _np
import scipy.sparse as _sparse

from pathpy.utils.exceptions import PathsTooShort
from pathpy.classes.network import Network


class HigherOrderNetwork(Network):
    &#34;&#34;&#34;
    A higher-order graphical model of path statistics with order k.

    Attributes:
    -----------

    edges: dict
        In a higher-order network, edge weights as well as in- and out
        weights of nodes are numpy arrays consisting of two weight components [w0, w1].
        w0 counts the weight of an edge based on its occurrence in a subpaths
        while w1 counts the weight of an edge based on its occurrence in
        a longest path. As an illustrating example, consider the single
        path a -&gt; b -&gt; c. In the first-order network, the weights of edges
        # (a,b) and (b,c) are both (1,0). In the second-order network, the
        weight of edge (a-b, b-c) is (0,1).
        Here, we will store these weights (as well as in- and out-degrees in
        node and edge attributes)
    &#34;&#34;&#34;

    def __init__(self, paths, k=1, null_model=False, separator=None):
        &#34;&#34;&#34;Generates a k-th-order representation based on the given path statistics.

        Parameters
        ----------
        paths: Path
            An instance of class Paths, which contains the path statistics to be used in
            the generation of the k-th order representation
        k: int
            The order of the network representation to generate. For the default case of
            k=1, the resulting representation corresponds to the usual (first-order)
            aggregate network, i.e. links connect nodes and link weights are given by the
            frequency of each interaction. For k&gt;1, a k-th order node corresponds to a
            sequence of k nodes. The weight of a k-th order link captures the frequency
            of a path of length k.
        null_model: bool
            For the default value False, link weights capture the frequencies of paths of length k 
            in the underlying paths object. If True, link weights capture expected frequencies
            under the assumption of independent links (i.e. corresponding to a first-order
            Markov model).
        separator: str
            The separator character to be used in higher-order node names. If this parameter 
            is not specified, the separator character of the underlying paths object will be 
            used.
        &#34;&#34;&#34;
        assert not null_model or (null_model and k &gt; 1)

        if not (paths.paths.keys() and max(paths.paths.keys()) &gt;= k):
            msg = (&#39;Constructing a model of order %d requires paths of at least length %d, &#39;
                   &#39;found paths of max length %d &#39; % (k, k, max(paths.paths.keys())))
            raise PathsTooShort(msg)

        super().__init__(directed=True)

        # The order of this HigherOrderNetwork
        self.order = k

        # The paths object used to generate this instance
        self.paths = paths

        self.is_null_model = null_model

        # The separator character used to label higher-order nodes.
        # For separator &#39;-&#39;, the name of a second-order node will be &#39;a-b&#39;.
        if separator is None:
            self.separator = paths.separator
        else:
            self.separator = separator

        if k &gt; 1:
            # For k&gt;1 we need the first-order network to generate the null model
            # and calculate the degrees of freedom

            # TODO: For a multi-order model, the first-order network is generated multiple
            # times! Make this more efficient
            g1 = HigherOrderNetwork(paths, k=1)
            g1_node_mapping = g1.node_to_name_map()
            A = g1.adjacency_matrix(include_subpaths=True, weighted=False,
                                    transposed=True)

        if not null_model:
            # Calculate the frequency of all paths of
            # length k, generate k-order nodes and set
            # edge weights accordingly
            iterator = paths.paths[k].items()

            if k == 0:
                # For a 0-order model, we generate a &#34;dummy&#34; start node
                self.add_node(&#39;start&#39;, inweight=_np.array([0.0, 0.0]), outweight=_np.array([0.0, 0.0]))
                for key, val in iterator:
                    w = key[0]
                    # add weight val to edge (&#39;start&#39;, w)
                    self.add_node(w, inweight=_np.array([0.0, 0.0]), outweight=_np.array([0.0, 0.0]))
                    self.add_edge(&#39;start&#39;, w, weight=val)
            else:
                for key, val in iterator:
                    # Generate names of k-order nodes v and w
                    v = self.separator.join(key[0:-1])
                    w = self.separator.join(key[1:])
                    self.add_node(v, inweight=_np.array([0.0, 0.0]), outweight=_np.array([0.0, 0.0]))
                    self.add_node(w, inweight=_np.array([0.0, 0.0]), outweight=_np.array([0.0, 0.0]))
                    # add weight val to directed edge (v,w)
                    self.add_edge(v, w, weight=val)
            
                # create all possible higher-order nodes
                if k &gt; 1:

                    nodes = HigherOrderNetwork.generate_possible_paths(g1, k-1)
                    for p in nodes:
                        v = p[0]                
                        for l in range(1, k):
                            v = v + self.separator + p[l]
                        
                        # create nodes and make sure that in- and out-weights are numpy arrays
                        if v not in self.nodes:
                            self.add_node(v, inweight=_np.array([0.0, 0.0]), outweight=_np.array([0.0, 0.0]))

            # Note: For all sequences of length k which (i) have never been observed, but
            #       (ii) do actually represent paths of length k in the first-order
            #       network, we may want to include some &#39;escape&#39; mechanism along the
            #       lines of (Cleary and Witten 1994)

        else:
            # generate the *expected* frequencies of all possible
            # paths of length k based on independently occurring (first-order) links
            possible_paths = HigherOrderNetwork.generate_possible_paths(g1, k)

            # validate that the number of unique paths corresponds to the sum
            # of entries in A**k
            A_sum = _np.sum(A ** k)
            assert A_sum == len(possible_paths), \
                &#39;Expected {ak} paths but got {re}&#39;.format(ak=A_sum, re=len(possible_paths))

            T = g1.transition_matrix(include_subpaths=True)

            # create nodes and links in k-th-order null model
            for p in possible_paths:
                # create higher-order nodes (a,b,c,...) and (b,c,d,...)
                v = p[0]
                for l in range(1, k):
                    v = v + self.separator + p[l]

                w = p[1]
                for l in range(2, k + 1):
                    w = w + self.separator + p[l]                    

                # create nodes and make sure that in- and out-weights are numpy arrays
                self.add_node(v, inweight=_np.array([0.0, 0.0]), outweight=_np.array([0.0, 0.0]))
                self.add_node(w, inweight=_np.array([0.0, 0.0]), outweight=_np.array([0.0, 0.0]))

                # In the null model, we encode a first-order Markov process in a k-th-order
                # model. For the transition probabilities e.g. (a,b) -&gt; (b,c) in a second-order
                # null model, we simply use the first-order transition probabilities, i.e. P(b-&gt;c).             
                # Note that transition_matrices are transposed (!)
                v_1, w_1 = g1_node_mapping[p[-2]], g1_node_mapping[p[-1]]
                p_vw = T[w_1, v_1]

                # We use first-order transition probabilities to create an expected frequency 
                # of paths of length k. For a path (a,b,c) we use the count of (a,b) and 
                # &#34;distribute&#34; it to all possible paths (a,b,*) according to the first-order 
                # transition probabilities of (b,*)
                expected_vw = paths.paths[k-1][p[:k]].sum() * p_vw

                self.add_edge(v, w, weight = _np.array([0, expected_vw]))

        # Compute degrees of freedom of models
        if k == 0:
            # for a zero-order model, we just fit node probabilities
            # (excluding the special &#39;start&#39; node)
            # Since probabilities must sum to one, the effective degree
            # of freedom is one less than the number of nodes
            # This holds for both the paths and the ngrams model
            self.dof_paths = self.ncount() - 2
            self.dof_ngrams = self.ncount() - 2
        else:
            # for a first-order model, self is the first-order network
            if k == 1:
                g1 = self
                A = g1.adjacency_matrix(include_subpaths=True, weighted=False,
                                        transposed=True)

            # Degrees of freedom in a higher-order ngram model
            s = g1.ncount()

            # The degrees of freedom of the higher-order model, under the ngram
            # assumption
            self.dof_ngrams = (s ** k) * (s - 1)

            # For k&gt;0, the degrees of freedom of a path-based model depend on
            # the number of possible paths of length k in the first-order network.
            # Since probabilities in each row must sum to one, the degrees
            # of freedom must be reduced by one for each k-order node
            # that has at least one possible transition.

            # (A**k).sum() counts the number of different paths of exactly length k
            # based on the first-order network, which corresponds to the number of
            # possible transitions in the transition matrix of a k-th order model.
            paths_k = (A ** k).sum()

            # For the degrees of freedom, we must additionally consider that
            # rows in the transition matrix must sum to one, i.e. we have to
            # subtract one degree of freedom for every non-zero row in the (null-model)
            # transition matrix. In other words, we subtract one for every path of
            # length k-1
            # that can possibly be followed by at least one edge to a path of length k

            # This can be calculated by counting the number of non-zero elements in the
            # vector containing the row sums of A**k
            non_zero = _np.count_nonzero((A ** k).sum(axis=0))

            # The degrees of freedom of the higher-order model, under the paths
            # assumption
            self.dof_paths = paths_k - non_zero


    @staticmethod
    def generate_possible_paths(network, k):
        &#34;&#34;&#34; Returns all paths of length k that can
        possibly exist in a given network &#34;&#34;&#34;

        assert k &gt; 0, &#39;This function only calculates possible paths of length k &gt; 0&#39;

        # start with edges, i.e. paths of length one
        possible_paths = list(network.edges.keys())

        # extend all of those paths by an edge k-1 times
        for _ in range(k - 1):
            E_new = list()
            for e1 in possible_paths:
                for e2 in network.edges:
                    if e1[-1] == e2[0]:
                        p = e1 + (e2[1],)
                        E_new.append(p)
            possible_paths = E_new
        return possible_paths


    def total_edge_weight(self):
        &#34;&#34;&#34; Returns the sum of all edge weights &#34;&#34;&#34;
        if self.edges:
            return sum(e[&#39;weight&#39;] for e in self.edges.values())
        return _np.array([0, 0])

    def model_size(self):
        &#34;&#34;&#34;
        Returns the number of non-zero elements in the adjacency matrix
        of the higher-order model.
        &#34;&#34;&#34;
        return self.adjacency_matrix().count_nonzero()

    def first_order_nodes(self):
        &#34;&#34;&#34;
        Returns a set of nodes projected to a first-order network
        &#34;&#34;&#34;
        nodes = set()
        for v in self.nodes:
            for w in self.higher_order_node_to_path(v):
                nodes.add(w)
        return nodes


    def higher_order_node_to_path(self, node):
        &#34;&#34;&#34;Helper function that transforms a node in a higher-order network of order k
        into a corresponding path of length k-1. For a higher-order node &#39;a-b-c-d&#39;
        this function will return (&#39;a&#39;,&#39;b&#39;,&#39;c&#39;,&#39;d&#39;)

        Parameters
        ----------
        node: str
            The higher-order node to be transformed to a path.

        Returns
        -------
        tuple
        &#34;&#34;&#34;
        return tuple(node.split(self.separator))

    def path_to_higher_order_nodes(self, path, k=None):
        &#34;&#34;&#34;Helper function that transforms a path of first-order nodes into a
        sequence of k-order nodes using the separator character of the
        HigherOrderNetwork instance

        Parameters
        ----------
        path:
            the path tuple to turn into a sequence of higher-order nodes
        k: int
            the order of the representation to use (default: order of the
            HigherOrderNetwork instance)

        Returns
        -------
        list

        Examples
        --------

        Consider an example path (a,b,c,d) with a separator string &#39;-&#39;

        &gt;&gt;&gt; from pathpy import Paths
        &gt;&gt;&gt; path_tuple = (&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;)
        &gt;&gt;&gt; paths = Paths()
        &gt;&gt;&gt; paths.add_path_tuple(path_tuple)
        &gt;&gt;&gt; hon = HigherOrderNetwork(paths, separator=&#39;-&#39;)
        &gt;&gt;&gt; hon.path_to_higher_order_nodes(path_tuple, k=1)
        [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;]
        &gt;&gt;&gt; hon.path_to_higher_order_nodes(path_tuple, k=2)
        [&#39;a-b&#39;, &#39;b-c&#39;, &#39;c-d&#39;]
        &gt;&gt;&gt; hon.path_to_higher_order_nodes(path_tuple, k=3)
        [&#39;a-b-c&#39;, &#39;b-c-d&#39;]
        &#34;&#34;&#34;

        if k is None:
            k = self.order
        assert len(path) &gt;= k, &#39;Error: Path length must be at least k&#39;

        if k == 0 and len(path) == 1:
            return [&#39;start&#39;, path[0]]

        return [self.separator.join(path[n:n + k]) for n in range(len(path) - k + 1)]

    def node_to_name_map(self):
        &#34;&#34;&#34;Returns a dictionary that can be used to map node names to matrix/vector indices&#34;&#34;&#34;
        return {v: idx for idx, v in enumerate(self.nodes)}

    def degrees_of_freedom(self, assumption=&#34;paths&#34;):
        &#34;&#34;&#34;Calculates the degrees of freedom (i.e. number of parameters) of
        this k-order model. Depending on the modeling assumptions, this either
        corresponds to the number of paths of length k in the first-order network
        or to the number of all possible k-grams. The degrees of freedom of a model
        can be used to assess the model complexity when calculating, e.g., the
        Bayesian Information Criterion (BIC).

        Parameters
        ----------
        assumption: str
            if set to &#39;paths&#39;, for the degree of freedom calculation in the BIC, only
            paths in the first-order network topology will be considered. This is needed
            whenever we are interested in a modeling of paths in a given network topology.
            If set to &#39;ngrams&#39; all possible n-grams will be considered, independent of
            whether they are valid paths in the first-order network or not. The &#39;ngrams&#39;
            and the &#39;paths&#39; assumption coincide if the first-order network is fully
            connected.

        Returns
        -------
        int
        &#34;&#34;&#34;
        assert assumption in [&#39;paths&#39;, &#39;ngrams&#39;], &#39;Error: Invalid assumption&#39;

        if assumption == &#39;paths&#39;:
            return self.dof_paths
        return self.dof_ngrams

    def higher_order_path_to_first_order(self, path):
        &#34;&#34;&#34;Maps a path in the higher-order network to a path in the first-order network.
        As an example, the second-order path (&#39;a-b&#39;, &#39;b-c&#39;, &#39;c-d&#39;) of length two is mapped
        to the first-order path (&#39;a&#39;,&#39;b&#39;,&#39;c&#39;,&#39;d&#39;) of length four.
        In general, a path of length l in a network of order k is mapped to a path of
        length l+k-1 in the first-order network.

        Parameters
        ----------
        path: str
            The higher-order path that shall be mapped to the first-order network

        Returns
        -------
        tuple
        &#34;&#34;&#34;
        p1 = self.higher_order_node_to_path(path[0])
        for x in path[1:]:
            p1 += (self.higher_order_node_to_path(x)[-1],)
        return p1

    def summary(self):
        &#34;&#34;&#34;Returns a string summary of this higher-order
           network
        &#34;&#34;&#34;
        summary_fmt = (
            &#39;Higher-order network of order k = {order}\n&#39;
            &#39;\n&#39;
            &#39;Nodes:\t\t\t\t{ncount}\n&#39;
            &#39;Links:\t\t\t\t{ecount}\n&#39;
            &#39;Total weight (subpaths/longest paths):\t{sub_w}/{uni_w}\n&#39;
        )
        summary = summary_fmt.format(
            order=self.order, ncount=self.ncount(), ecount=self.ecount(),
            sub_w=self.total_edge_weight()[0], uni_w=self.total_edge_weight()[1]
        )
        return summary

    def likelihood(self, paths, log=True):
        &#34;&#34;&#34;
        Calculates the likelihood of this higher-order model under the observed path 
        statistics given in paths.
        &#34;&#34;&#34;
        if log:
            L = 0.0
        else: 
            L = 1.0
        T = self.transition_matrix()
        node_map = self.node_to_name_map()
        for l in paths.paths:
            if l&gt;=self.order:
                for p in paths.paths[l]:
                    if paths.paths[l][p][1]&gt;0:
                        if log:
                            path_L = 0.0
                        else:
                            path_L = 1.0
                        node_sequence = self.path_to_higher_order_nodes(p)
                        prev = node_sequence[0]
                        for n in node_sequence[1:]:
                            if log:
                                path_L += _np.log(T[node_map[n], node_map[prev]])
                            else:
                                path_L *= T[node_map[n], node_map[prev]]
                            prev = n
                        if log:
                            L += path_L * paths.paths[l][p][1]
                        else: 
                            L *= path_L ** paths.paths[l][p][1]
        return L


    def adjacency_matrix(self, include_subpaths=True, weighted=True, transposed=False):
        &#34;&#34;&#34;Returns a sparse adjacency matrix of the higher-order network. By default,
        the entry corresponding to a directed link source -&gt; target is stored in row s and
        column t and can be accessed via A[s,t].

        Parameters
        ----------
        include_subpaths: bool
            if set to True, the returned adjacency matrix will account for the occurrence
            of links of order k (i.e. paths of length k-1) as subpaths
        weighted: bool
            if set to False, the function returns a binary adjacency matrix.
            If set to True, adjacency matrix entries will contain the weight of an edge.
        transposed: bool
            whether to transpose the matrix or not.

        Returns
        -------
        numpy cooc matrix
        &#34;&#34;&#34;
        row = []
        col = []
        data = []

        node_to_coord = self.node_to_name_map()

        if transposed:
            for s, t in self.edges:
                row.append(node_to_coord[t])
                col.append(node_to_coord[s])
        else:
            for s, t in self.edges:
                row.append(node_to_coord[s])
                col.append(node_to_coord[t])

        # create array with non-zero entries
        if not weighted:
            data = _np.ones(len(self.edges.keys()))
        else:
            if include_subpaths:
                data = _np.array([float(self.edges[e][&#39;weight&#39;].sum()) for e in self.edges])
            else:
                data = _np.array([float(self.edges[e][&#39;weight&#39;][1]) for e in self.edges])

        shape = (self.ncount(), self.ncount())
        return _sparse.coo_matrix((data, (row, col)), shape=shape).tocsr()


    def transition_matrix(self, include_subpaths=True):
        &#34;&#34;&#34;Returns a (transposed) random walk transition matrix corresponding to the
        higher-order network.

        Parameters
        ----------
        include_subpaths: bool
            whether or not to include subpath statistics in the transition probability
            calculation (default True)

        Returns
        -------

        &#34;&#34;&#34;
        row = []
        col = []
        data = []
        # calculate weighted out-degrees (with or without subpaths)
        if include_subpaths:
            D = {n: self.nodes[n][&#39;outweight&#39;].sum() for n in self.nodes}
        else:
            D = {n: self.nodes[n][&#39;outweight&#39;][1] for n in self.nodes}

        node_to_coord = self.node_to_name_map()

        for (s, t) in self.edges:
            # either s-&gt;t has been observed as a longest path, or we are interested in
            # subpaths as well

            # the following makes sure that we do not accidentally consider zero-weight
            # edges (automatically added by default_dic)
            unique_weight = self.edges[(s, t)][&#39;weight&#39;][1]
            subpath_weight = self.edges[(s, t)][&#39;weight&#39;][0]
            is_valid = (unique_weight &gt; 0 or (include_subpaths and subpath_weight &gt; 0))
            if is_valid:
                row.append(node_to_coord[t])
                col.append(node_to_coord[s])
                if include_subpaths:
                    count = self.edges[(s, t)][&#39;weight&#39;].sum()
                else:
                    count = self.edges[(s, t)][&#39;weight&#39;][1]
                assert D[s] &gt; 0, \
                    &#39;Encountered zero out-degree for node &#34;{s}&#34; &#39; \
                    &#39;while weight of link ({s}, {t}) is non-zero.&#39;.format(s=s, t=t)
                prob = count / D[s]
                if prob &lt; 0 or prob &gt; 1:  # pragma: no cover
                    raise ValueError(&#39;Encountered transition probability {p} outside &#39;
                                     &#39;[0,1] range.&#39;.format(p=prob))
                data.append(prob)

        data = _np.array(data)
        data = data.reshape(data.size, )

        shape = self.ncount(), self.ncount()
        return _sparse.coo_matrix((data, (row, col)), shape=shape).tocsr()


    def laplacian_matrix(self, include_subpaths=True):
        &#34;&#34;&#34;
        Returns the transposed Laplacian matrix corresponding to the higher-order network.

        Parameters
        ----------
        include_subpaths: bool
            Whether or not subpath statistics shall be included in the calculation of
            matrix weights

        Returns
        -------

        &#34;&#34;&#34;
        transition_matrix = self.transition_matrix(include_subpaths)
        identity_matrix = _sparse.identity(self.ncount())

        return identity_matrix - transition_matrix</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="pathpy.classes.higher_order_network.HigherOrderNetwork"><code class="flex name class">
<span>class <span class="ident">HigherOrderNetwork</span></span>
<span>(</span><span><small>ancestors:</small> <a title="pathpy.classes.network.Network" href="network.html#pathpy.classes.network.Network">Network</a>)</span>
</code></dt>
<dd>
<section class="desc"><p>A higher-order graphical model of path statistics with order k.</p>
<h2 id="attributes">Attributes:</h2>
<dl>
<dt><strong><code>edges</code></strong> :&ensp;<code>dict</code></dt>
<dd>In a higher-order network, edge weights as well as in- and out
weights of nodes are numpy arrays consisting of two weight components [w0, w1].
w0 counts the weight of an edge based on its occurrence in a subpaths
while w1 counts the weight of an edge based on its occurrence in
a longest path. As an illustrating example, consider the single
path a -&gt; b -&gt; c. In the first-order network, the weights of edges<h1 id="ab-and-bc-are-both-10-in-the-second-order-network-the">(a,b) and (b,c) are both (1,0). In the second-order network, the</h1>
weight of edge (a-b, b-c) is (0,1).
Here, we will store these weights (as well as in- and out-degrees in
node and edge attributes)</dd>
</dl></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">class HigherOrderNetwork(Network):
    &#34;&#34;&#34;
    A higher-order graphical model of path statistics with order k.

    Attributes:
    -----------

    edges: dict
        In a higher-order network, edge weights as well as in- and out
        weights of nodes are numpy arrays consisting of two weight components [w0, w1].
        w0 counts the weight of an edge based on its occurrence in a subpaths
        while w1 counts the weight of an edge based on its occurrence in
        a longest path. As an illustrating example, consider the single
        path a -&gt; b -&gt; c. In the first-order network, the weights of edges
        # (a,b) and (b,c) are both (1,0). In the second-order network, the
        weight of edge (a-b, b-c) is (0,1).
        Here, we will store these weights (as well as in- and out-degrees in
        node and edge attributes)
    &#34;&#34;&#34;

    def __init__(self, paths, k=1, null_model=False, separator=None):
        &#34;&#34;&#34;Generates a k-th-order representation based on the given path statistics.

        Parameters
        ----------
        paths: Path
            An instance of class Paths, which contains the path statistics to be used in
            the generation of the k-th order representation
        k: int
            The order of the network representation to generate. For the default case of
            k=1, the resulting representation corresponds to the usual (first-order)
            aggregate network, i.e. links connect nodes and link weights are given by the
            frequency of each interaction. For k&gt;1, a k-th order node corresponds to a
            sequence of k nodes. The weight of a k-th order link captures the frequency
            of a path of length k.
        null_model: bool
            For the default value False, link weights capture the frequencies of paths of length k 
            in the underlying paths object. If True, link weights capture expected frequencies
            under the assumption of independent links (i.e. corresponding to a first-order
            Markov model).
        separator: str
            The separator character to be used in higher-order node names. If this parameter 
            is not specified, the separator character of the underlying paths object will be 
            used.
        &#34;&#34;&#34;
        assert not null_model or (null_model and k &gt; 1)

        if not (paths.paths.keys() and max(paths.paths.keys()) &gt;= k):
            msg = (&#39;Constructing a model of order %d requires paths of at least length %d, &#39;
                   &#39;found paths of max length %d &#39; % (k, k, max(paths.paths.keys())))
            raise PathsTooShort(msg)

        super().__init__(directed=True)

        # The order of this HigherOrderNetwork
        self.order = k

        # The paths object used to generate this instance
        self.paths = paths

        self.is_null_model = null_model

        # The separator character used to label higher-order nodes.
        # For separator &#39;-&#39;, the name of a second-order node will be &#39;a-b&#39;.
        if separator is None:
            self.separator = paths.separator
        else:
            self.separator = separator

        if k &gt; 1:
            # For k&gt;1 we need the first-order network to generate the null model
            # and calculate the degrees of freedom

            # TODO: For a multi-order model, the first-order network is generated multiple
            # times! Make this more efficient
            g1 = HigherOrderNetwork(paths, k=1)
            g1_node_mapping = g1.node_to_name_map()
            A = g1.adjacency_matrix(include_subpaths=True, weighted=False,
                                    transposed=True)

        if not null_model:
            # Calculate the frequency of all paths of
            # length k, generate k-order nodes and set
            # edge weights accordingly
            iterator = paths.paths[k].items()

            if k == 0:
                # For a 0-order model, we generate a &#34;dummy&#34; start node
                self.add_node(&#39;start&#39;, inweight=_np.array([0.0, 0.0]), outweight=_np.array([0.0, 0.0]))
                for key, val in iterator:
                    w = key[0]
                    # add weight val to edge (&#39;start&#39;, w)
                    self.add_node(w, inweight=_np.array([0.0, 0.0]), outweight=_np.array([0.0, 0.0]))
                    self.add_edge(&#39;start&#39;, w, weight=val)
            else:
                for key, val in iterator:
                    # Generate names of k-order nodes v and w
                    v = self.separator.join(key[0:-1])
                    w = self.separator.join(key[1:])
                    self.add_node(v, inweight=_np.array([0.0, 0.0]), outweight=_np.array([0.0, 0.0]))
                    self.add_node(w, inweight=_np.array([0.0, 0.0]), outweight=_np.array([0.0, 0.0]))
                    # add weight val to directed edge (v,w)
                    self.add_edge(v, w, weight=val)
            
                # create all possible higher-order nodes
                if k &gt; 1:

                    nodes = HigherOrderNetwork.generate_possible_paths(g1, k-1)
                    for p in nodes:
                        v = p[0]                
                        for l in range(1, k):
                            v = v + self.separator + p[l]
                        
                        # create nodes and make sure that in- and out-weights are numpy arrays
                        if v not in self.nodes:
                            self.add_node(v, inweight=_np.array([0.0, 0.0]), outweight=_np.array([0.0, 0.0]))

            # Note: For all sequences of length k which (i) have never been observed, but
            #       (ii) do actually represent paths of length k in the first-order
            #       network, we may want to include some &#39;escape&#39; mechanism along the
            #       lines of (Cleary and Witten 1994)

        else:
            # generate the *expected* frequencies of all possible
            # paths of length k based on independently occurring (first-order) links
            possible_paths = HigherOrderNetwork.generate_possible_paths(g1, k)

            # validate that the number of unique paths corresponds to the sum
            # of entries in A**k
            A_sum = _np.sum(A ** k)
            assert A_sum == len(possible_paths), \
                &#39;Expected {ak} paths but got {re}&#39;.format(ak=A_sum, re=len(possible_paths))

            T = g1.transition_matrix(include_subpaths=True)

            # create nodes and links in k-th-order null model
            for p in possible_paths:
                # create higher-order nodes (a,b,c,...) and (b,c,d,...)
                v = p[0]
                for l in range(1, k):
                    v = v + self.separator + p[l]

                w = p[1]
                for l in range(2, k + 1):
                    w = w + self.separator + p[l]                    

                # create nodes and make sure that in- and out-weights are numpy arrays
                self.add_node(v, inweight=_np.array([0.0, 0.0]), outweight=_np.array([0.0, 0.0]))
                self.add_node(w, inweight=_np.array([0.0, 0.0]), outweight=_np.array([0.0, 0.0]))

                # In the null model, we encode a first-order Markov process in a k-th-order
                # model. For the transition probabilities e.g. (a,b) -&gt; (b,c) in a second-order
                # null model, we simply use the first-order transition probabilities, i.e. P(b-&gt;c).             
                # Note that transition_matrices are transposed (!)
                v_1, w_1 = g1_node_mapping[p[-2]], g1_node_mapping[p[-1]]
                p_vw = T[w_1, v_1]

                # We use first-order transition probabilities to create an expected frequency 
                # of paths of length k. For a path (a,b,c) we use the count of (a,b) and 
                # &#34;distribute&#34; it to all possible paths (a,b,*) according to the first-order 
                # transition probabilities of (b,*)
                expected_vw = paths.paths[k-1][p[:k]].sum() * p_vw

                self.add_edge(v, w, weight = _np.array([0, expected_vw]))

        # Compute degrees of freedom of models
        if k == 0:
            # for a zero-order model, we just fit node probabilities
            # (excluding the special &#39;start&#39; node)
            # Since probabilities must sum to one, the effective degree
            # of freedom is one less than the number of nodes
            # This holds for both the paths and the ngrams model
            self.dof_paths = self.ncount() - 2
            self.dof_ngrams = self.ncount() - 2
        else:
            # for a first-order model, self is the first-order network
            if k == 1:
                g1 = self
                A = g1.adjacency_matrix(include_subpaths=True, weighted=False,
                                        transposed=True)

            # Degrees of freedom in a higher-order ngram model
            s = g1.ncount()

            # The degrees of freedom of the higher-order model, under the ngram
            # assumption
            self.dof_ngrams = (s ** k) * (s - 1)

            # For k&gt;0, the degrees of freedom of a path-based model depend on
            # the number of possible paths of length k in the first-order network.
            # Since probabilities in each row must sum to one, the degrees
            # of freedom must be reduced by one for each k-order node
            # that has at least one possible transition.

            # (A**k).sum() counts the number of different paths of exactly length k
            # based on the first-order network, which corresponds to the number of
            # possible transitions in the transition matrix of a k-th order model.
            paths_k = (A ** k).sum()

            # For the degrees of freedom, we must additionally consider that
            # rows in the transition matrix must sum to one, i.e. we have to
            # subtract one degree of freedom for every non-zero row in the (null-model)
            # transition matrix. In other words, we subtract one for every path of
            # length k-1
            # that can possibly be followed by at least one edge to a path of length k

            # This can be calculated by counting the number of non-zero elements in the
            # vector containing the row sums of A**k
            non_zero = _np.count_nonzero((A ** k).sum(axis=0))

            # The degrees of freedom of the higher-order model, under the paths
            # assumption
            self.dof_paths = paths_k - non_zero


    @staticmethod
    def generate_possible_paths(network, k):
        &#34;&#34;&#34; Returns all paths of length k that can
        possibly exist in a given network &#34;&#34;&#34;

        assert k &gt; 0, &#39;This function only calculates possible paths of length k &gt; 0&#39;

        # start with edges, i.e. paths of length one
        possible_paths = list(network.edges.keys())

        # extend all of those paths by an edge k-1 times
        for _ in range(k - 1):
            E_new = list()
            for e1 in possible_paths:
                for e2 in network.edges:
                    if e1[-1] == e2[0]:
                        p = e1 + (e2[1],)
                        E_new.append(p)
            possible_paths = E_new
        return possible_paths


    def total_edge_weight(self):
        &#34;&#34;&#34; Returns the sum of all edge weights &#34;&#34;&#34;
        if self.edges:
            return sum(e[&#39;weight&#39;] for e in self.edges.values())
        return _np.array([0, 0])

    def model_size(self):
        &#34;&#34;&#34;
        Returns the number of non-zero elements in the adjacency matrix
        of the higher-order model.
        &#34;&#34;&#34;
        return self.adjacency_matrix().count_nonzero()

    def first_order_nodes(self):
        &#34;&#34;&#34;
        Returns a set of nodes projected to a first-order network
        &#34;&#34;&#34;
        nodes = set()
        for v in self.nodes:
            for w in self.higher_order_node_to_path(v):
                nodes.add(w)
        return nodes


    def higher_order_node_to_path(self, node):
        &#34;&#34;&#34;Helper function that transforms a node in a higher-order network of order k
        into a corresponding path of length k-1. For a higher-order node &#39;a-b-c-d&#39;
        this function will return (&#39;a&#39;,&#39;b&#39;,&#39;c&#39;,&#39;d&#39;)

        Parameters
        ----------
        node: str
            The higher-order node to be transformed to a path.

        Returns
        -------
        tuple
        &#34;&#34;&#34;
        return tuple(node.split(self.separator))

    def path_to_higher_order_nodes(self, path, k=None):
        &#34;&#34;&#34;Helper function that transforms a path of first-order nodes into a
        sequence of k-order nodes using the separator character of the
        HigherOrderNetwork instance

        Parameters
        ----------
        path:
            the path tuple to turn into a sequence of higher-order nodes
        k: int
            the order of the representation to use (default: order of the
            HigherOrderNetwork instance)

        Returns
        -------
        list

        Examples
        --------

        Consider an example path (a,b,c,d) with a separator string &#39;-&#39;

        &gt;&gt;&gt; from pathpy import Paths
        &gt;&gt;&gt; path_tuple = (&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;)
        &gt;&gt;&gt; paths = Paths()
        &gt;&gt;&gt; paths.add_path_tuple(path_tuple)
        &gt;&gt;&gt; hon = HigherOrderNetwork(paths, separator=&#39;-&#39;)
        &gt;&gt;&gt; hon.path_to_higher_order_nodes(path_tuple, k=1)
        [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;]
        &gt;&gt;&gt; hon.path_to_higher_order_nodes(path_tuple, k=2)
        [&#39;a-b&#39;, &#39;b-c&#39;, &#39;c-d&#39;]
        &gt;&gt;&gt; hon.path_to_higher_order_nodes(path_tuple, k=3)
        [&#39;a-b-c&#39;, &#39;b-c-d&#39;]
        &#34;&#34;&#34;

        if k is None:
            k = self.order
        assert len(path) &gt;= k, &#39;Error: Path length must be at least k&#39;

        if k == 0 and len(path) == 1:
            return [&#39;start&#39;, path[0]]

        return [self.separator.join(path[n:n + k]) for n in range(len(path) - k + 1)]

    def node_to_name_map(self):
        &#34;&#34;&#34;Returns a dictionary that can be used to map node names to matrix/vector indices&#34;&#34;&#34;
        return {v: idx for idx, v in enumerate(self.nodes)}

    def degrees_of_freedom(self, assumption=&#34;paths&#34;):
        &#34;&#34;&#34;Calculates the degrees of freedom (i.e. number of parameters) of
        this k-order model. Depending on the modeling assumptions, this either
        corresponds to the number of paths of length k in the first-order network
        or to the number of all possible k-grams. The degrees of freedom of a model
        can be used to assess the model complexity when calculating, e.g., the
        Bayesian Information Criterion (BIC).

        Parameters
        ----------
        assumption: str
            if set to &#39;paths&#39;, for the degree of freedom calculation in the BIC, only
            paths in the first-order network topology will be considered. This is needed
            whenever we are interested in a modeling of paths in a given network topology.
            If set to &#39;ngrams&#39; all possible n-grams will be considered, independent of
            whether they are valid paths in the first-order network or not. The &#39;ngrams&#39;
            and the &#39;paths&#39; assumption coincide if the first-order network is fully
            connected.

        Returns
        -------
        int
        &#34;&#34;&#34;
        assert assumption in [&#39;paths&#39;, &#39;ngrams&#39;], &#39;Error: Invalid assumption&#39;

        if assumption == &#39;paths&#39;:
            return self.dof_paths
        return self.dof_ngrams

    def higher_order_path_to_first_order(self, path):
        &#34;&#34;&#34;Maps a path in the higher-order network to a path in the first-order network.
        As an example, the second-order path (&#39;a-b&#39;, &#39;b-c&#39;, &#39;c-d&#39;) of length two is mapped
        to the first-order path (&#39;a&#39;,&#39;b&#39;,&#39;c&#39;,&#39;d&#39;) of length four.
        In general, a path of length l in a network of order k is mapped to a path of
        length l+k-1 in the first-order network.

        Parameters
        ----------
        path: str
            The higher-order path that shall be mapped to the first-order network

        Returns
        -------
        tuple
        &#34;&#34;&#34;
        p1 = self.higher_order_node_to_path(path[0])
        for x in path[1:]:
            p1 += (self.higher_order_node_to_path(x)[-1],)
        return p1

    def summary(self):
        &#34;&#34;&#34;Returns a string summary of this higher-order
           network
        &#34;&#34;&#34;
        summary_fmt = (
            &#39;Higher-order network of order k = {order}\n&#39;
            &#39;\n&#39;
            &#39;Nodes:\t\t\t\t{ncount}\n&#39;
            &#39;Links:\t\t\t\t{ecount}\n&#39;
            &#39;Total weight (subpaths/longest paths):\t{sub_w}/{uni_w}\n&#39;
        )
        summary = summary_fmt.format(
            order=self.order, ncount=self.ncount(), ecount=self.ecount(),
            sub_w=self.total_edge_weight()[0], uni_w=self.total_edge_weight()[1]
        )
        return summary

    def likelihood(self, paths, log=True):
        &#34;&#34;&#34;
        Calculates the likelihood of this higher-order model under the observed path 
        statistics given in paths.
        &#34;&#34;&#34;
        if log:
            L = 0.0
        else: 
            L = 1.0
        T = self.transition_matrix()
        node_map = self.node_to_name_map()
        for l in paths.paths:
            if l&gt;=self.order:
                for p in paths.paths[l]:
                    if paths.paths[l][p][1]&gt;0:
                        if log:
                            path_L = 0.0
                        else:
                            path_L = 1.0
                        node_sequence = self.path_to_higher_order_nodes(p)
                        prev = node_sequence[0]
                        for n in node_sequence[1:]:
                            if log:
                                path_L += _np.log(T[node_map[n], node_map[prev]])
                            else:
                                path_L *= T[node_map[n], node_map[prev]]
                            prev = n
                        if log:
                            L += path_L * paths.paths[l][p][1]
                        else: 
                            L *= path_L ** paths.paths[l][p][1]
        return L


    def adjacency_matrix(self, include_subpaths=True, weighted=True, transposed=False):
        &#34;&#34;&#34;Returns a sparse adjacency matrix of the higher-order network. By default,
        the entry corresponding to a directed link source -&gt; target is stored in row s and
        column t and can be accessed via A[s,t].

        Parameters
        ----------
        include_subpaths: bool
            if set to True, the returned adjacency matrix will account for the occurrence
            of links of order k (i.e. paths of length k-1) as subpaths
        weighted: bool
            if set to False, the function returns a binary adjacency matrix.
            If set to True, adjacency matrix entries will contain the weight of an edge.
        transposed: bool
            whether to transpose the matrix or not.

        Returns
        -------
        numpy cooc matrix
        &#34;&#34;&#34;
        row = []
        col = []
        data = []

        node_to_coord = self.node_to_name_map()

        if transposed:
            for s, t in self.edges:
                row.append(node_to_coord[t])
                col.append(node_to_coord[s])
        else:
            for s, t in self.edges:
                row.append(node_to_coord[s])
                col.append(node_to_coord[t])

        # create array with non-zero entries
        if not weighted:
            data = _np.ones(len(self.edges.keys()))
        else:
            if include_subpaths:
                data = _np.array([float(self.edges[e][&#39;weight&#39;].sum()) for e in self.edges])
            else:
                data = _np.array([float(self.edges[e][&#39;weight&#39;][1]) for e in self.edges])

        shape = (self.ncount(), self.ncount())
        return _sparse.coo_matrix((data, (row, col)), shape=shape).tocsr()


    def transition_matrix(self, include_subpaths=True):
        &#34;&#34;&#34;Returns a (transposed) random walk transition matrix corresponding to the
        higher-order network.

        Parameters
        ----------
        include_subpaths: bool
            whether or not to include subpath statistics in the transition probability
            calculation (default True)

        Returns
        -------

        &#34;&#34;&#34;
        row = []
        col = []
        data = []
        # calculate weighted out-degrees (with or without subpaths)
        if include_subpaths:
            D = {n: self.nodes[n][&#39;outweight&#39;].sum() for n in self.nodes}
        else:
            D = {n: self.nodes[n][&#39;outweight&#39;][1] for n in self.nodes}

        node_to_coord = self.node_to_name_map()

        for (s, t) in self.edges:
            # either s-&gt;t has been observed as a longest path, or we are interested in
            # subpaths as well

            # the following makes sure that we do not accidentally consider zero-weight
            # edges (automatically added by default_dic)
            unique_weight = self.edges[(s, t)][&#39;weight&#39;][1]
            subpath_weight = self.edges[(s, t)][&#39;weight&#39;][0]
            is_valid = (unique_weight &gt; 0 or (include_subpaths and subpath_weight &gt; 0))
            if is_valid:
                row.append(node_to_coord[t])
                col.append(node_to_coord[s])
                if include_subpaths:
                    count = self.edges[(s, t)][&#39;weight&#39;].sum()
                else:
                    count = self.edges[(s, t)][&#39;weight&#39;][1]
                assert D[s] &gt; 0, \
                    &#39;Encountered zero out-degree for node &#34;{s}&#34; &#39; \
                    &#39;while weight of link ({s}, {t}) is non-zero.&#39;.format(s=s, t=t)
                prob = count / D[s]
                if prob &lt; 0 or prob &gt; 1:  # pragma: no cover
                    raise ValueError(&#39;Encountered transition probability {p} outside &#39;
                                     &#39;[0,1] range.&#39;.format(p=prob))
                data.append(prob)

        data = _np.array(data)
        data = data.reshape(data.size, )

        shape = self.ncount(), self.ncount()
        return _sparse.coo_matrix((data, (row, col)), shape=shape).tocsr()


    def laplacian_matrix(self, include_subpaths=True):
        &#34;&#34;&#34;
        Returns the transposed Laplacian matrix corresponding to the higher-order network.

        Parameters
        ----------
        include_subpaths: bool
            Whether or not subpath statistics shall be included in the calculation of
            matrix weights

        Returns
        -------

        &#34;&#34;&#34;
        transition_matrix = self.transition_matrix(include_subpaths)
        identity_matrix = _sparse.identity(self.ncount())

        return identity_matrix - transition_matrix</code></pre>
</details>
<h3>Static methods</h3>
<dl>
<dt id="pathpy.classes.higher_order_network.HigherOrderNetwork.generate_possible_paths"><code class="name flex">
<span>def <span class="ident">generate_possible_paths</span></span>(<span>network, k)</span>
</code></dt>
<dd>
<section class="desc"><p>Returns all paths of length k that can
possibly exist in a given network</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">@staticmethod
def generate_possible_paths(network, k):
    &#34;&#34;&#34; Returns all paths of length k that can
    possibly exist in a given network &#34;&#34;&#34;

    assert k &gt; 0, &#39;This function only calculates possible paths of length k &gt; 0&#39;

    # start with edges, i.e. paths of length one
    possible_paths = list(network.edges.keys())

    # extend all of those paths by an edge k-1 times
    for _ in range(k - 1):
        E_new = list()
        for e1 in possible_paths:
            for e2 in network.edges:
                if e1[-1] == e2[0]:
                    p = e1 + (e2[1],)
                    E_new.append(p)
        possible_paths = E_new
    return possible_paths</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="pathpy.classes.higher_order_network.HigherOrderNetwork.__init__"><code class="name flex">
<span>def <span class="ident">__init__</span></span>(<span>self, paths, k=1, null_model=False, separator=None)</span>
</code></dt>
<dd>
<section class="desc"><p>Generates a k-th-order representation based on the given path statistics.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>paths</code></strong> :&ensp;<code>Path</code></dt>
<dd>An instance of class Paths, which contains the path statistics to be used in
the generation of the k-th order representation</dd>
<dt><strong><code>k</code></strong> :&ensp;<code>int</code></dt>
<dd>The order of the network representation to generate. For the default case of
k=1, the resulting representation corresponds to the usual (first-order)
aggregate network, i.e. links connect nodes and link weights are given by the
frequency of each interaction. For k&gt;1, a k-th order node corresponds to a
sequence of k nodes. The weight of a k-th order link captures the frequency
of a path of length k.</dd>
<dt><strong><code>null_model</code></strong> :&ensp;<code>bool</code></dt>
<dd>For the default value False, link weights capture the frequencies of paths of length k
in the underlying paths object. If True, link weights capture expected frequencies
under the assumption of independent links (i.e. corresponding to a first-order
Markov model).</dd>
<dt><strong><code>separator</code></strong> :&ensp;<code>str</code></dt>
<dd>The separator character to be used in higher-order node names. If this parameter
is not specified, the separator character of the underlying paths object will be
used.</dd>
</dl></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def __init__(self, paths, k=1, null_model=False, separator=None):
    &#34;&#34;&#34;Generates a k-th-order representation based on the given path statistics.

    Parameters
    ----------
    paths: Path
        An instance of class Paths, which contains the path statistics to be used in
        the generation of the k-th order representation
    k: int
        The order of the network representation to generate. For the default case of
        k=1, the resulting representation corresponds to the usual (first-order)
        aggregate network, i.e. links connect nodes and link weights are given by the
        frequency of each interaction. For k&gt;1, a k-th order node corresponds to a
        sequence of k nodes. The weight of a k-th order link captures the frequency
        of a path of length k.
    null_model: bool
        For the default value False, link weights capture the frequencies of paths of length k 
        in the underlying paths object. If True, link weights capture expected frequencies
        under the assumption of independent links (i.e. corresponding to a first-order
        Markov model).
    separator: str
        The separator character to be used in higher-order node names. If this parameter 
        is not specified, the separator character of the underlying paths object will be 
        used.
    &#34;&#34;&#34;
    assert not null_model or (null_model and k &gt; 1)

    if not (paths.paths.keys() and max(paths.paths.keys()) &gt;= k):
        msg = (&#39;Constructing a model of order %d requires paths of at least length %d, &#39;
               &#39;found paths of max length %d &#39; % (k, k, max(paths.paths.keys())))
        raise PathsTooShort(msg)

    super().__init__(directed=True)

    # The order of this HigherOrderNetwork
    self.order = k

    # The paths object used to generate this instance
    self.paths = paths

    self.is_null_model = null_model

    # The separator character used to label higher-order nodes.
    # For separator &#39;-&#39;, the name of a second-order node will be &#39;a-b&#39;.
    if separator is None:
        self.separator = paths.separator
    else:
        self.separator = separator

    if k &gt; 1:
        # For k&gt;1 we need the first-order network to generate the null model
        # and calculate the degrees of freedom

        # TODO: For a multi-order model, the first-order network is generated multiple
        # times! Make this more efficient
        g1 = HigherOrderNetwork(paths, k=1)
        g1_node_mapping = g1.node_to_name_map()
        A = g1.adjacency_matrix(include_subpaths=True, weighted=False,
                                transposed=True)

    if not null_model:
        # Calculate the frequency of all paths of
        # length k, generate k-order nodes and set
        # edge weights accordingly
        iterator = paths.paths[k].items()

        if k == 0:
            # For a 0-order model, we generate a &#34;dummy&#34; start node
            self.add_node(&#39;start&#39;, inweight=_np.array([0.0, 0.0]), outweight=_np.array([0.0, 0.0]))
            for key, val in iterator:
                w = key[0]
                # add weight val to edge (&#39;start&#39;, w)
                self.add_node(w, inweight=_np.array([0.0, 0.0]), outweight=_np.array([0.0, 0.0]))
                self.add_edge(&#39;start&#39;, w, weight=val)
        else:
            for key, val in iterator:
                # Generate names of k-order nodes v and w
                v = self.separator.join(key[0:-1])
                w = self.separator.join(key[1:])
                self.add_node(v, inweight=_np.array([0.0, 0.0]), outweight=_np.array([0.0, 0.0]))
                self.add_node(w, inweight=_np.array([0.0, 0.0]), outweight=_np.array([0.0, 0.0]))
                # add weight val to directed edge (v,w)
                self.add_edge(v, w, weight=val)
        
            # create all possible higher-order nodes
            if k &gt; 1:

                nodes = HigherOrderNetwork.generate_possible_paths(g1, k-1)
                for p in nodes:
                    v = p[0]                
                    for l in range(1, k):
                        v = v + self.separator + p[l]
                    
                    # create nodes and make sure that in- and out-weights are numpy arrays
                    if v not in self.nodes:
                        self.add_node(v, inweight=_np.array([0.0, 0.0]), outweight=_np.array([0.0, 0.0]))

        # Note: For all sequences of length k which (i) have never been observed, but
        #       (ii) do actually represent paths of length k in the first-order
        #       network, we may want to include some &#39;escape&#39; mechanism along the
        #       lines of (Cleary and Witten 1994)

    else:
        # generate the *expected* frequencies of all possible
        # paths of length k based on independently occurring (first-order) links
        possible_paths = HigherOrderNetwork.generate_possible_paths(g1, k)

        # validate that the number of unique paths corresponds to the sum
        # of entries in A**k
        A_sum = _np.sum(A ** k)
        assert A_sum == len(possible_paths), \
            &#39;Expected {ak} paths but got {re}&#39;.format(ak=A_sum, re=len(possible_paths))

        T = g1.transition_matrix(include_subpaths=True)

        # create nodes and links in k-th-order null model
        for p in possible_paths:
            # create higher-order nodes (a,b,c,...) and (b,c,d,...)
            v = p[0]
            for l in range(1, k):
                v = v + self.separator + p[l]

            w = p[1]
            for l in range(2, k + 1):
                w = w + self.separator + p[l]                    

            # create nodes and make sure that in- and out-weights are numpy arrays
            self.add_node(v, inweight=_np.array([0.0, 0.0]), outweight=_np.array([0.0, 0.0]))
            self.add_node(w, inweight=_np.array([0.0, 0.0]), outweight=_np.array([0.0, 0.0]))

            # In the null model, we encode a first-order Markov process in a k-th-order
            # model. For the transition probabilities e.g. (a,b) -&gt; (b,c) in a second-order
            # null model, we simply use the first-order transition probabilities, i.e. P(b-&gt;c).             
            # Note that transition_matrices are transposed (!)
            v_1, w_1 = g1_node_mapping[p[-2]], g1_node_mapping[p[-1]]
            p_vw = T[w_1, v_1]

            # We use first-order transition probabilities to create an expected frequency 
            # of paths of length k. For a path (a,b,c) we use the count of (a,b) and 
            # &#34;distribute&#34; it to all possible paths (a,b,*) according to the first-order 
            # transition probabilities of (b,*)
            expected_vw = paths.paths[k-1][p[:k]].sum() * p_vw

            self.add_edge(v, w, weight = _np.array([0, expected_vw]))

    # Compute degrees of freedom of models
    if k == 0:
        # for a zero-order model, we just fit node probabilities
        # (excluding the special &#39;start&#39; node)
        # Since probabilities must sum to one, the effective degree
        # of freedom is one less than the number of nodes
        # This holds for both the paths and the ngrams model
        self.dof_paths = self.ncount() - 2
        self.dof_ngrams = self.ncount() - 2
    else:
        # for a first-order model, self is the first-order network
        if k == 1:
            g1 = self
            A = g1.adjacency_matrix(include_subpaths=True, weighted=False,
                                    transposed=True)

        # Degrees of freedom in a higher-order ngram model
        s = g1.ncount()

        # The degrees of freedom of the higher-order model, under the ngram
        # assumption
        self.dof_ngrams = (s ** k) * (s - 1)

        # For k&gt;0, the degrees of freedom of a path-based model depend on
        # the number of possible paths of length k in the first-order network.
        # Since probabilities in each row must sum to one, the degrees
        # of freedom must be reduced by one for each k-order node
        # that has at least one possible transition.

        # (A**k).sum() counts the number of different paths of exactly length k
        # based on the first-order network, which corresponds to the number of
        # possible transitions in the transition matrix of a k-th order model.
        paths_k = (A ** k).sum()

        # For the degrees of freedom, we must additionally consider that
        # rows in the transition matrix must sum to one, i.e. we have to
        # subtract one degree of freedom for every non-zero row in the (null-model)
        # transition matrix. In other words, we subtract one for every path of
        # length k-1
        # that can possibly be followed by at least one edge to a path of length k

        # This can be calculated by counting the number of non-zero elements in the
        # vector containing the row sums of A**k
        non_zero = _np.count_nonzero((A ** k).sum(axis=0))

        # The degrees of freedom of the higher-order model, under the paths
        # assumption
        self.dof_paths = paths_k - non_zero</code></pre>
</details>
</dd>
<dt id="pathpy.classes.higher_order_network.HigherOrderNetwork.adjacency_matrix"><code class="name flex">
<span>def <span class="ident">adjacency_matrix</span></span>(<span>self, include_subpaths=True, weighted=True, transposed=False)</span>
</code></dt>
<dd>
<section class="desc"><p>Returns a sparse adjacency matrix of the higher-order network. By default,
the entry corresponding to a directed link source -&gt; target is stored in row s and
column t and can be accessed via A[s,t].</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>include_subpaths</code></strong> :&ensp;<code>bool</code></dt>
<dd>if set to True, the returned adjacency matrix will account for the occurrence
of links of order k (i.e. paths of length k-1) as subpaths</dd>
<dt><strong><code>weighted</code></strong> :&ensp;<code>bool</code></dt>
<dd>if set to False, the function returns a binary adjacency matrix.
If set to True, adjacency matrix entries will contain the weight of an edge.</dd>
<dt><strong><code>transposed</code></strong> :&ensp;<code>bool</code></dt>
<dd>whether to transpose the matrix or not.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>numpy cooc matrix</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def adjacency_matrix(self, include_subpaths=True, weighted=True, transposed=False):
    &#34;&#34;&#34;Returns a sparse adjacency matrix of the higher-order network. By default,
    the entry corresponding to a directed link source -&gt; target is stored in row s and
    column t and can be accessed via A[s,t].

    Parameters
    ----------
    include_subpaths: bool
        if set to True, the returned adjacency matrix will account for the occurrence
        of links of order k (i.e. paths of length k-1) as subpaths
    weighted: bool
        if set to False, the function returns a binary adjacency matrix.
        If set to True, adjacency matrix entries will contain the weight of an edge.
    transposed: bool
        whether to transpose the matrix or not.

    Returns
    -------
    numpy cooc matrix
    &#34;&#34;&#34;
    row = []
    col = []
    data = []

    node_to_coord = self.node_to_name_map()

    if transposed:
        for s, t in self.edges:
            row.append(node_to_coord[t])
            col.append(node_to_coord[s])
    else:
        for s, t in self.edges:
            row.append(node_to_coord[s])
            col.append(node_to_coord[t])

    # create array with non-zero entries
    if not weighted:
        data = _np.ones(len(self.edges.keys()))
    else:
        if include_subpaths:
            data = _np.array([float(self.edges[e][&#39;weight&#39;].sum()) for e in self.edges])
        else:
            data = _np.array([float(self.edges[e][&#39;weight&#39;][1]) for e in self.edges])

    shape = (self.ncount(), self.ncount())
    return _sparse.coo_matrix((data, (row, col)), shape=shape).tocsr()</code></pre>
</details>
</dd>
<dt id="pathpy.classes.higher_order_network.HigherOrderNetwork.degrees_of_freedom"><code class="name flex">
<span>def <span class="ident">degrees_of_freedom</span></span>(<span>self, assumption=&#39;paths&#39;)</span>
</code></dt>
<dd>
<section class="desc"><p>Calculates the degrees of freedom (i.e. number of parameters) of
this k-order model. Depending on the modeling assumptions, this either
corresponds to the number of paths of length k in the first-order network
or to the number of all possible k-grams. The degrees of freedom of a model
can be used to assess the model complexity when calculating, e.g., the
Bayesian Information Criterion (BIC).</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>assumption</code></strong> :&ensp;<code>str</code></dt>
<dd>if set to 'paths', for the degree of freedom calculation in the BIC, only
paths in the first-order network topology will be considered. This is needed
whenever we are interested in a modeling of paths in a given network topology.
If set to 'ngrams' all possible n-grams will be considered, independent of
whether they are valid paths in the first-order network or not. The 'ngrams'
and the 'paths' assumption coincide if the first-order network is fully
connected.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>int</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def degrees_of_freedom(self, assumption=&#34;paths&#34;):
    &#34;&#34;&#34;Calculates the degrees of freedom (i.e. number of parameters) of
    this k-order model. Depending on the modeling assumptions, this either
    corresponds to the number of paths of length k in the first-order network
    or to the number of all possible k-grams. The degrees of freedom of a model
    can be used to assess the model complexity when calculating, e.g., the
    Bayesian Information Criterion (BIC).

    Parameters
    ----------
    assumption: str
        if set to &#39;paths&#39;, for the degree of freedom calculation in the BIC, only
        paths in the first-order network topology will be considered. This is needed
        whenever we are interested in a modeling of paths in a given network topology.
        If set to &#39;ngrams&#39; all possible n-grams will be considered, independent of
        whether they are valid paths in the first-order network or not. The &#39;ngrams&#39;
        and the &#39;paths&#39; assumption coincide if the first-order network is fully
        connected.

    Returns
    -------
    int
    &#34;&#34;&#34;
    assert assumption in [&#39;paths&#39;, &#39;ngrams&#39;], &#39;Error: Invalid assumption&#39;

    if assumption == &#39;paths&#39;:
        return self.dof_paths
    return self.dof_ngrams</code></pre>
</details>
</dd>
<dt id="pathpy.classes.higher_order_network.HigherOrderNetwork.first_order_nodes"><code class="name flex">
<span>def <span class="ident">first_order_nodes</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>Returns a set of nodes projected to a first-order network</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def first_order_nodes(self):
    &#34;&#34;&#34;
    Returns a set of nodes projected to a first-order network
    &#34;&#34;&#34;
    nodes = set()
    for v in self.nodes:
        for w in self.higher_order_node_to_path(v):
            nodes.add(w)
    return nodes</code></pre>
</details>
</dd>
<dt id="pathpy.classes.higher_order_network.HigherOrderNetwork.higher_order_node_to_path"><code class="name flex">
<span>def <span class="ident">higher_order_node_to_path</span></span>(<span>self, node)</span>
</code></dt>
<dd>
<section class="desc"><p>Helper function that transforms a node in a higher-order network of order k
into a corresponding path of length k-1. For a higher-order node 'a-b-c-d'
this function will return ('a','b','c','d')</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>node</code></strong> :&ensp;<code>str</code></dt>
<dd>The higher-order node to be transformed to a path.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>tuple</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def higher_order_node_to_path(self, node):
    &#34;&#34;&#34;Helper function that transforms a node in a higher-order network of order k
    into a corresponding path of length k-1. For a higher-order node &#39;a-b-c-d&#39;
    this function will return (&#39;a&#39;,&#39;b&#39;,&#39;c&#39;,&#39;d&#39;)

    Parameters
    ----------
    node: str
        The higher-order node to be transformed to a path.

    Returns
    -------
    tuple
    &#34;&#34;&#34;
    return tuple(node.split(self.separator))</code></pre>
</details>
</dd>
<dt id="pathpy.classes.higher_order_network.HigherOrderNetwork.higher_order_path_to_first_order"><code class="name flex">
<span>def <span class="ident">higher_order_path_to_first_order</span></span>(<span>self, path)</span>
</code></dt>
<dd>
<section class="desc"><p>Maps a path in the higher-order network to a path in the first-order network.
As an example, the second-order path ('a-b', 'b-c', 'c-d') of length two is mapped
to the first-order path ('a','b','c','d') of length four.
In general, a path of length l in a network of order k is mapped to a path of
length l+k-1 in the first-order network.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>path</code></strong> :&ensp;<code>str</code></dt>
<dd>The higher-order path that shall be mapped to the first-order network</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>tuple</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def higher_order_path_to_first_order(self, path):
    &#34;&#34;&#34;Maps a path in the higher-order network to a path in the first-order network.
    As an example, the second-order path (&#39;a-b&#39;, &#39;b-c&#39;, &#39;c-d&#39;) of length two is mapped
    to the first-order path (&#39;a&#39;,&#39;b&#39;,&#39;c&#39;,&#39;d&#39;) of length four.
    In general, a path of length l in a network of order k is mapped to a path of
    length l+k-1 in the first-order network.

    Parameters
    ----------
    path: str
        The higher-order path that shall be mapped to the first-order network

    Returns
    -------
    tuple
    &#34;&#34;&#34;
    p1 = self.higher_order_node_to_path(path[0])
    for x in path[1:]:
        p1 += (self.higher_order_node_to_path(x)[-1],)
    return p1</code></pre>
</details>
</dd>
<dt id="pathpy.classes.higher_order_network.HigherOrderNetwork.laplacian_matrix"><code class="name flex">
<span>def <span class="ident">laplacian_matrix</span></span>(<span>self, include_subpaths=True)</span>
</code></dt>
<dd>
<section class="desc"><p>Returns the transposed Laplacian matrix corresponding to the higher-order network.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>include_subpaths</code></strong> :&ensp;<code>bool</code></dt>
<dd>Whether or not subpath statistics shall be included in the calculation of
matrix weights</dd>
</dl>
<h2 id="returns">Returns</h2></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def laplacian_matrix(self, include_subpaths=True):
    &#34;&#34;&#34;
    Returns the transposed Laplacian matrix corresponding to the higher-order network.

    Parameters
    ----------
    include_subpaths: bool
        Whether or not subpath statistics shall be included in the calculation of
        matrix weights

    Returns
    -------

    &#34;&#34;&#34;
    transition_matrix = self.transition_matrix(include_subpaths)
    identity_matrix = _sparse.identity(self.ncount())

    return identity_matrix - transition_matrix</code></pre>
</details>
</dd>
<dt id="pathpy.classes.higher_order_network.HigherOrderNetwork.likelihood"><code class="name flex">
<span>def <span class="ident">likelihood</span></span>(<span>self, paths, log=True)</span>
</code></dt>
<dd>
<section class="desc"><p>Calculates the likelihood of this higher-order model under the observed path
statistics given in paths.</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def likelihood(self, paths, log=True):
    &#34;&#34;&#34;
    Calculates the likelihood of this higher-order model under the observed path 
    statistics given in paths.
    &#34;&#34;&#34;
    if log:
        L = 0.0
    else: 
        L = 1.0
    T = self.transition_matrix()
    node_map = self.node_to_name_map()
    for l in paths.paths:
        if l&gt;=self.order:
            for p in paths.paths[l]:
                if paths.paths[l][p][1]&gt;0:
                    if log:
                        path_L = 0.0
                    else:
                        path_L = 1.0
                    node_sequence = self.path_to_higher_order_nodes(p)
                    prev = node_sequence[0]
                    for n in node_sequence[1:]:
                        if log:
                            path_L += _np.log(T[node_map[n], node_map[prev]])
                        else:
                            path_L *= T[node_map[n], node_map[prev]]
                        prev = n
                    if log:
                        L += path_L * paths.paths[l][p][1]
                    else: 
                        L *= path_L ** paths.paths[l][p][1]
    return L</code></pre>
</details>
</dd>
<dt id="pathpy.classes.higher_order_network.HigherOrderNetwork.model_size"><code class="name flex">
<span>def <span class="ident">model_size</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>Returns the number of non-zero elements in the adjacency matrix
of the higher-order model.</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def model_size(self):
    &#34;&#34;&#34;
    Returns the number of non-zero elements in the adjacency matrix
    of the higher-order model.
    &#34;&#34;&#34;
    return self.adjacency_matrix().count_nonzero()</code></pre>
</details>
</dd>
<dt id="pathpy.classes.higher_order_network.HigherOrderNetwork.node_to_name_map"><code class="name flex">
<span>def <span class="ident">node_to_name_map</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>Returns a dictionary that can be used to map node names to matrix/vector indices</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def node_to_name_map(self):
    &#34;&#34;&#34;Returns a dictionary that can be used to map node names to matrix/vector indices&#34;&#34;&#34;
    return {v: idx for idx, v in enumerate(self.nodes)}</code></pre>
</details>
</dd>
<dt id="pathpy.classes.higher_order_network.HigherOrderNetwork.path_to_higher_order_nodes"><code class="name flex">
<span>def <span class="ident">path_to_higher_order_nodes</span></span>(<span>self, path, k=None)</span>
</code></dt>
<dd>
<section class="desc"><p>Helper function that transforms a path of first-order nodes into a
sequence of k-order nodes using the separator character of the
HigherOrderNetwork instance</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt>path:</dt>
<dt>the path tuple to turn into a sequence of higher-order nodes</dt>
<dt><strong><code>k</code></strong> :&ensp;<code>int</code></dt>
<dd>the order of the representation to use (default: order of the
HigherOrderNetwork instance)</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>list</p>
<h2 id="examples">Examples</h2>
<p>Consider an example path (a,b,c,d) with a separator string '-'</p>
<pre><code>&gt;&gt;&gt; from pathpy import Paths
&gt;&gt;&gt; path_tuple = ('a', 'b', 'c', 'd')
&gt;&gt;&gt; paths = Paths()
&gt;&gt;&gt; paths.add_path_tuple(path_tuple)
&gt;&gt;&gt; hon = HigherOrderNetwork(paths, separator='-')
&gt;&gt;&gt; hon.path_to_higher_order_nodes(path_tuple, k=1)
['a', 'b', 'c', 'd']
&gt;&gt;&gt; hon.path_to_higher_order_nodes(path_tuple, k=2)
['a-b', 'b-c', 'c-d']
&gt;&gt;&gt; hon.path_to_higher_order_nodes(path_tuple, k=3)
</code></pre>
<p>['a-b-c', 'b-c-d']</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def path_to_higher_order_nodes(self, path, k=None):
    &#34;&#34;&#34;Helper function that transforms a path of first-order nodes into a
    sequence of k-order nodes using the separator character of the
    HigherOrderNetwork instance

    Parameters
    ----------
    path:
        the path tuple to turn into a sequence of higher-order nodes
    k: int
        the order of the representation to use (default: order of the
        HigherOrderNetwork instance)

    Returns
    -------
    list

    Examples
    --------

    Consider an example path (a,b,c,d) with a separator string &#39;-&#39;

    &gt;&gt;&gt; from pathpy import Paths
    &gt;&gt;&gt; path_tuple = (&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;)
    &gt;&gt;&gt; paths = Paths()
    &gt;&gt;&gt; paths.add_path_tuple(path_tuple)
    &gt;&gt;&gt; hon = HigherOrderNetwork(paths, separator=&#39;-&#39;)
    &gt;&gt;&gt; hon.path_to_higher_order_nodes(path_tuple, k=1)
    [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;]
    &gt;&gt;&gt; hon.path_to_higher_order_nodes(path_tuple, k=2)
    [&#39;a-b&#39;, &#39;b-c&#39;, &#39;c-d&#39;]
    &gt;&gt;&gt; hon.path_to_higher_order_nodes(path_tuple, k=3)
    [&#39;a-b-c&#39;, &#39;b-c-d&#39;]
    &#34;&#34;&#34;

    if k is None:
        k = self.order
    assert len(path) &gt;= k, &#39;Error: Path length must be at least k&#39;

    if k == 0 and len(path) == 1:
        return [&#39;start&#39;, path[0]]

    return [self.separator.join(path[n:n + k]) for n in range(len(path) - k + 1)]</code></pre>
</details>
</dd>
<dt id="pathpy.classes.higher_order_network.HigherOrderNetwork.summary"><code class="name flex">
<span>def <span class="ident">summary</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>Returns a string summary of this higher-order
network</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def summary(self):
    &#34;&#34;&#34;Returns a string summary of this higher-order
       network
    &#34;&#34;&#34;
    summary_fmt = (
        &#39;Higher-order network of order k = {order}\n&#39;
        &#39;\n&#39;
        &#39;Nodes:\t\t\t\t{ncount}\n&#39;
        &#39;Links:\t\t\t\t{ecount}\n&#39;
        &#39;Total weight (subpaths/longest paths):\t{sub_w}/{uni_w}\n&#39;
    )
    summary = summary_fmt.format(
        order=self.order, ncount=self.ncount(), ecount=self.ecount(),
        sub_w=self.total_edge_weight()[0], uni_w=self.total_edge_weight()[1]
    )
    return summary</code></pre>
</details>
</dd>
<dt id="pathpy.classes.higher_order_network.HigherOrderNetwork.transition_matrix"><code class="name flex">
<span>def <span class="ident">transition_matrix</span></span>(<span>self, include_subpaths=True)</span>
</code></dt>
<dd>
<section class="desc"><p>Returns a (transposed) random walk transition matrix corresponding to the
higher-order network.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>include_subpaths</code></strong> :&ensp;<code>bool</code></dt>
<dd>whether or not to include subpath statistics in the transition probability
calculation (default True)</dd>
</dl>
<h2 id="returns">Returns</h2></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def transition_matrix(self, include_subpaths=True):
    &#34;&#34;&#34;Returns a (transposed) random walk transition matrix corresponding to the
    higher-order network.

    Parameters
    ----------
    include_subpaths: bool
        whether or not to include subpath statistics in the transition probability
        calculation (default True)

    Returns
    -------

    &#34;&#34;&#34;
    row = []
    col = []
    data = []
    # calculate weighted out-degrees (with or without subpaths)
    if include_subpaths:
        D = {n: self.nodes[n][&#39;outweight&#39;].sum() for n in self.nodes}
    else:
        D = {n: self.nodes[n][&#39;outweight&#39;][1] for n in self.nodes}

    node_to_coord = self.node_to_name_map()

    for (s, t) in self.edges:
        # either s-&gt;t has been observed as a longest path, or we are interested in
        # subpaths as well

        # the following makes sure that we do not accidentally consider zero-weight
        # edges (automatically added by default_dic)
        unique_weight = self.edges[(s, t)][&#39;weight&#39;][1]
        subpath_weight = self.edges[(s, t)][&#39;weight&#39;][0]
        is_valid = (unique_weight &gt; 0 or (include_subpaths and subpath_weight &gt; 0))
        if is_valid:
            row.append(node_to_coord[t])
            col.append(node_to_coord[s])
            if include_subpaths:
                count = self.edges[(s, t)][&#39;weight&#39;].sum()
            else:
                count = self.edges[(s, t)][&#39;weight&#39;][1]
            assert D[s] &gt; 0, \
                &#39;Encountered zero out-degree for node &#34;{s}&#34; &#39; \
                &#39;while weight of link ({s}, {t}) is non-zero.&#39;.format(s=s, t=t)
            prob = count / D[s]
            if prob &lt; 0 or prob &gt; 1:  # pragma: no cover
                raise ValueError(&#39;Encountered transition probability {p} outside &#39;
                                 &#39;[0,1] range.&#39;.format(p=prob))
            data.append(prob)

    data = _np.array(data)
    data = data.reshape(data.size, )

    shape = self.ncount(), self.ncount()
    return _sparse.coo_matrix((data, (row, col)), shape=shape).tocsr()</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="pathpy.classes.network.Network" href="network.html#pathpy.classes.network.Network">Network</a></b></code>:
<ul class="hlist">
<li><code><a title="pathpy.classes.network.Network.add_clique" href="network.html#pathpy.classes.network.Network.add_clique">add_clique</a></code></li>
<li><code><a title="pathpy.classes.network.Network.add_edge" href="network.html#pathpy.classes.network.Network.add_edge">add_edge</a></code></li>
<li><code><a title="pathpy.classes.network.Network.add_node" href="network.html#pathpy.classes.network.Network.add_node">add_node</a></code></li>
<li><code><a title="pathpy.classes.network.Network.degrees" href="network.html#pathpy.classes.network.Network.degrees">degrees</a></code></li>
<li><code><a title="pathpy.classes.network.Network.ecount" href="network.html#pathpy.classes.network.Network.ecount">ecount</a></code></li>
<li><code><a title="pathpy.classes.network.Network.find_edges" href="network.html#pathpy.classes.network.Network.find_edges">find_edges</a></code></li>
<li><code><a title="pathpy.classes.network.Network.find_nodes" href="network.html#pathpy.classes.network.Network.find_nodes">find_nodes</a></code></li>
<li><code><a title="pathpy.classes.network.Network.from_paths" href="network.html#pathpy.classes.network.Network.from_paths">from_paths</a></code></li>
<li><code><a title="pathpy.classes.network.Network.from_sqlite" href="network.html#pathpy.classes.network.Network.from_sqlite">from_sqlite</a></code></li>
<li><code><a title="pathpy.classes.network.Network.from_temporal_network" href="network.html#pathpy.classes.network.Network.from_temporal_network">from_temporal_network</a></code></li>
<li><code><a title="pathpy.classes.network.Network.leading_eigenvector" href="network.html#pathpy.classes.network.Network.leading_eigenvector">leading_eigenvector</a></code></li>
<li><code><a title="pathpy.classes.network.Network.ncount" href="network.html#pathpy.classes.network.Network.ncount">ncount</a></code></li>
<li><code><a title="pathpy.classes.network.Network.node_properties" href="network.html#pathpy.classes.network.Network.node_properties">node_properties</a></code></li>
<li><code><a title="pathpy.classes.network.Network.read_file" href="network.html#pathpy.classes.network.Network.read_file">read_file</a></code></li>
<li><code><a title="pathpy.classes.network.Network.remove_edge" href="network.html#pathpy.classes.network.Network.remove_edge">remove_edge</a></code></li>
<li><code><a title="pathpy.classes.network.Network.remove_node" href="network.html#pathpy.classes.network.Network.remove_node">remove_node</a></code></li>
<li><code><a title="pathpy.classes.network.Network.to_undirected" href="network.html#pathpy.classes.network.Network.to_undirected">to_undirected</a></code></li>
<li><code><a title="pathpy.classes.network.Network.to_unweighted" href="network.html#pathpy.classes.network.Network.to_unweighted">to_unweighted</a></code></li>
<li><code><a title="pathpy.classes.network.Network.total_edge_weight" href="network.html#pathpy.classes.network.Network.total_edge_weight">total_edge_weight</a></code></li>
<li><code><a title="pathpy.classes.network.Network.write_file" href="network.html#pathpy.classes.network.Network.write_file">write_file</a></code></li>
</ul>
</li>
</ul>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="pathpy.classes" href="index.html">pathpy.classes</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="pathpy.classes.higher_order_network.HigherOrderNetwork" href="#pathpy.classes.higher_order_network.HigherOrderNetwork">HigherOrderNetwork</a></code></h4>
<ul class="">
<li><code><a title="pathpy.classes.higher_order_network.HigherOrderNetwork.__init__" href="#pathpy.classes.higher_order_network.HigherOrderNetwork.__init__">__init__</a></code></li>
<li><code><a title="pathpy.classes.higher_order_network.HigherOrderNetwork.adjacency_matrix" href="#pathpy.classes.higher_order_network.HigherOrderNetwork.adjacency_matrix">adjacency_matrix</a></code></li>
<li><code><a title="pathpy.classes.higher_order_network.HigherOrderNetwork.degrees_of_freedom" href="#pathpy.classes.higher_order_network.HigherOrderNetwork.degrees_of_freedom">degrees_of_freedom</a></code></li>
<li><code><a title="pathpy.classes.higher_order_network.HigherOrderNetwork.first_order_nodes" href="#pathpy.classes.higher_order_network.HigherOrderNetwork.first_order_nodes">first_order_nodes</a></code></li>
<li><code><a title="pathpy.classes.higher_order_network.HigherOrderNetwork.generate_possible_paths" href="#pathpy.classes.higher_order_network.HigherOrderNetwork.generate_possible_paths">generate_possible_paths</a></code></li>
<li><code><a title="pathpy.classes.higher_order_network.HigherOrderNetwork.higher_order_node_to_path" href="#pathpy.classes.higher_order_network.HigherOrderNetwork.higher_order_node_to_path">higher_order_node_to_path</a></code></li>
<li><code><a title="pathpy.classes.higher_order_network.HigherOrderNetwork.higher_order_path_to_first_order" href="#pathpy.classes.higher_order_network.HigherOrderNetwork.higher_order_path_to_first_order">higher_order_path_to_first_order</a></code></li>
<li><code><a title="pathpy.classes.higher_order_network.HigherOrderNetwork.laplacian_matrix" href="#pathpy.classes.higher_order_network.HigherOrderNetwork.laplacian_matrix">laplacian_matrix</a></code></li>
<li><code><a title="pathpy.classes.higher_order_network.HigherOrderNetwork.likelihood" href="#pathpy.classes.higher_order_network.HigherOrderNetwork.likelihood">likelihood</a></code></li>
<li><code><a title="pathpy.classes.higher_order_network.HigherOrderNetwork.model_size" href="#pathpy.classes.higher_order_network.HigherOrderNetwork.model_size">model_size</a></code></li>
<li><code><a title="pathpy.classes.higher_order_network.HigherOrderNetwork.node_to_name_map" href="#pathpy.classes.higher_order_network.HigherOrderNetwork.node_to_name_map">node_to_name_map</a></code></li>
<li><code><a title="pathpy.classes.higher_order_network.HigherOrderNetwork.path_to_higher_order_nodes" href="#pathpy.classes.higher_order_network.HigherOrderNetwork.path_to_higher_order_nodes">path_to_higher_order_nodes</a></code></li>
<li><code><a title="pathpy.classes.higher_order_network.HigherOrderNetwork.summary" href="#pathpy.classes.higher_order_network.HigherOrderNetwork.summary">summary</a></code></li>
<li><code><a title="pathpy.classes.higher_order_network.HigherOrderNetwork.transition_matrix" href="#pathpy.classes.higher_order_network.HigherOrderNetwork.transition_matrix">transition_matrix</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.5.3</a>.</p>
</footer>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
<script>hljs.initHighlightingOnLoad()</script>
</body>
</html>