<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.5.3" />
<title>pathpy.classes.dag API documentation</title>
<meta name="description" content="" />
<link href='https://cdnjs.cloudflare.com/ajax/libs/normalize/8.0.0/normalize.min.css' rel='stylesheet'>
<link href='https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/8.0.0/sanitize.min.css' rel='stylesheet'>
<link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/github.min.css" rel="stylesheet">
<style>.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{font-weight:bold}#index h4 + ul{margin-bottom:.6em}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.name small{font-weight:normal}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase;cursor:pointer}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}.admonition{padding:.1em .5em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title"><code>pathpy.classes.dag</code> module</h1>
</header>
<section id="section-intro">
<details class="source">
<summary>Source code</summary>
<pre><code class="python"># -*- coding: utf-8 -*-

#    pathpy is an OpenSource python package for the analysis of time series data
#    on networks using higher- and multi order graphical models.
#
#    Copyright (C) 2016-2018 Ingo Scholtes, ETH Zürich/Universität Zürich
#
#    This program is free software: you can redistribute it and/or modify
#    it under the terms of the GNU Affero General Public License as published
#    by the Free Software Foundation, either version 3 of the License, or
#    (at your option) any later version.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU Affero General Public License for more details.
#
#    You should have received a copy of the GNU Affero General Public License
#    along with this program. If not, see &lt;http://www.gnu.org/licenses/&gt;.
#
#    Contact the developer:
#
#    E-mail: scholtes@ifi.uzh.ch
#    Web:    http://www.ingoscholtes.net
from collections import defaultdict
from pathpy.utils import Log, Severity
from pathpy.classes.network import Network


class DAG(Network):
    &#34;&#34;&#34;
        A directed acyclic graph (DAG) which
        can be used to generate pathway statistics.
    &#34;&#34;&#34;

    def __init__(self, edges=None):
        &#34;&#34;&#34;
        Constructs a directed acyclic graph from an edge list
        &#34;&#34;&#34;

        super().__init__(directed=True)

        # Whether or not this graph is acyclic. None indicates that it is unknown
        self.is_acyclic = None

        # list of topologically sorted nodes
        self.sorting = []

        # Set of nodes with no incoming edges
        self.roots = set()

        # Set of nodes with no outgoing edges
        self.leafs = set()

        if edges is not None:
            self.add_edges(edges)

        # placeholder properties for topological sort
        self.parent = {}
        self.start_time = {}
        self.finish_time = {}
        self.edge_classes = {}
        self.top_sort_count = 0


    @classmethod
    def from_node_activity_sequence(cls, sequence, self_loops=True, connect_prior=0):
        &#34;&#34;&#34;
        Generates a directed acyclic graph from a sequence of node
        activations, where each activation is assumed to be influenced
        by previous activations. This is useful to extract a
        directed acyclic graph, e.g., from a sequence of user activities
        in a communication forum. The sequence of interactions is taken into
        account in the generation of the DAG. The number of prior activations to
        each node will be linked can be customized using the connect_prior parameter.
        For the default 0 (which means connect to all prior activations), a sequence
        [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;a&#39;] will result in a dag (0,1), (0,2), (0,3), (1,2), (1,3), (2,3).
        The returned node_map maps the nodes in the DAG to the actual nodes, i.e. in the example
        node_map = { &#39;0&#39;: &#39;a&#39;, &#39;1&#39;: &#39;b&#39;, &#39;2&#39;: c, &#39;3&#39;: a}.

        Parameter:
        ----------
        sequence: iterable
            any iterable containing a sequence of string node names
        self_loops: bool
            whether or not to consider links linking nodes to themselves, i.e. whether
            to consider an edge (x, y) in the dag where node_map[x] == node_map[y]
        connect_prior: bool
            to how many prior nodes each node shall be linked. For a value of 1, a chain 
            will be generated, for 2 a lattice where each node is connected to two previous
            nodes is generated. For the default 0 each node is connected to all prior nodes.
        &#34;&#34;&#34;
        dag = cls()

        # dictionary that maps nodes in dag to actual nodes
        node_map = {}

        i = 0
        for v in sequence:
            name = str(i)
            node_map[name] = v
            dag.add_node(name)
            if connect_prior == 0:
                m = i
            else:
                m = min(connect_prior, i)
            for j in range(i-m, i):
                if self_loops or node_map[str(j)] != node_map[name]:
                    dag.add_edge(str(j), name)            
            i += 1
        return dag, node_map


    @classmethod
    def from_temporal_network(cls, tempnet, delta=1):
        &#34;&#34;&#34;
        Creates a time-unfolded directed acyclic graph from a
        temporal network for a given maximum time difference delta.

        Parameters
        ----------
        tempnet: pp.TemporalNetwork
            The temporal network instance to use for the DAG generation.

        delta: int
            The maximum time difference t&#39;- t between two time-stamped edges
            (a,b,t) and (b,c,t&#39;) up to which a causal path (a, b, c) is a
            created in the DAG

        &#34;&#34;&#34;
        dag = cls()

        # dictionary that maps time-unfolded nodes to actual nodes
        node_map = {}

        for (v, w, t) in tempnet.tedges:
            # create time-unfolded nodes v_t and w_{t+1}
            v_t = &#34;{0}_{1}&#34;.format(v, t)
            node_map[v_t] = v

            # create one time-unfolded link for all delta in [1, delta]
            # this implies that for delta = 2 and an edge (a,b,1) two 
            # time-unfolded links (a_1, b_2) and (a_1, b_3) will be created
            for x in range(1, int(delta)+1):
                w_t = &#34;{0}_{1}&#34;.format(w, t+x)
                node_map[w_t] = w
                dag.add_edge(v_t, w_t)

        return dag, node_map


    def add_edges(self, edges):
        &#34;&#34;&#34;Add a list of edges

        Parameters
        ----------
        edges: list
            a list of edges [(s_1, t_1), (s_1, t_2), ...]

        &#34;&#34;&#34;
        self_loops = 0
        redundant_edges = 0
        for e in edges:
            is_redundant = False
            has_self_loop = False
            if e[0] == e[1]:
                has_self_loop = True
                self_loops += 1
            if (e[0], e[1]) in self.edges:
                is_redundant = True
                redundant_edges += 1
            if not has_self_loop and not is_redundant:
                self.add_edge(e[0], e[1])
        if self_loops &gt; 0:
            Log.add(&#39;Warning: omitted %d self-loops&#39; % self_loops, Severity.WARNING)
        if redundant_edges &gt; 0:
            Log.add(&#39;Warning: omitted %d redundant edges&#39; % redundant_edges,
                    Severity.WARNING)

    def routes_from_node(self, v, node_mapping=None):
        &#34;&#34;&#34;
        Constructs all paths from node v to any leaf nodes

        Parameters
        ----------
        v:
            node from which to start
        node_mapping: dict
            an optional mapping from node to a different set.

        Returns
        -------
        list
            a list of lists, where each list contains one path from the source
            node v until a leaf node is reached
        &#34;&#34;&#34;
        # Collect temporary paths, indexed by the target node
        temp_paths = defaultdict(list)
        temp_paths[v] = [[v]]

        # set of unprocessed nodes
        queue = {v}

        while queue:
            # take one unprocessed node
            x = queue.pop()

            # successors of x expand all temporary
            # paths, currently ending in x
            if self.successors[x]:
                for w in self.successors[x]:
                    for p in temp_paths[x]:
                        temp_paths[w].append(p + [w])
                    queue.add(w)
                del temp_paths[x]

        # flatten list
        final_paths = []
        for possible_paths in temp_paths.values():
            for path in possible_paths:
                if node_mapping:
                    path = [node_mapping[k] for k in path]
                final_paths.append(path)

        return final_paths

    def routes_to_node(self, v, node_mapping=None):
        &#34;&#34;&#34;
        Constructs all paths to node v from any root node

        Parameters
        ----------
        v:
            node from which to start
        node_mapping: dict
            an optional mapping from node to a different set.

        Returns
        -------
        list
            a list of lists, where each list contains one path from the source
            node v until a leaf node is reached
        &#34;&#34;&#34;
        # Collect temporary paths, indexed by the target node
        temp_paths = defaultdict(list)
        temp_paths[v] = [[v]]

        # set of unprocessed nodes
        queue = {v}

        while queue:
            # take one unprocessed node
            x = queue.pop()

            # successors of x expand all temporary
            # paths, currently ending in x
            if self.predecessors[x]:
                for w in self.predecessors[x]:
                    for p in temp_paths[x]:
                        temp_paths[w].append(p + [w])
                    queue.add(w)
                del temp_paths[x]

        # flatten list
        final_paths = []
        for possible_paths in temp_paths.values():
            for path in possible_paths:
                path = list(reversed(path))
                if node_mapping:
                    path = [node_mapping[k] for k in path]
                final_paths.append(path)

        return final_paths

    def dfs_visit(self, v, parent=None):
        &#34;&#34;&#34;Recursively visits nodes in the graph, classifying edges as (1) tree, (2)
        forward, (3) back or (4) cross edges.

        Parameters
        ----------
        v:
            node to be visited
        parent:
            the parent of this node (None for nodes) with no parents
        &#34;&#34;&#34;
        self.parent[v] = parent
        self.top_sort_count += 1
        self.start_time[v] = self.top_sort_count
        if parent:
            self.edge_classes[(parent, v)] = &#39;tree&#39;

        for w in self.successors[v]:
            if w not in self.parent:
                self.dfs_visit(w, v)
            elif w not in self.finish_time:
                self.edge_classes[(v, w)] = &#39;back&#39;
                self.is_acyclic = False
            elif self.start_time[v] &lt; self.start_time[w]:
                self.edge_classes[(v, w)] = &#39;forward&#39;
            else:
                self.edge_classes[(v, w)] = &#39;cross&#39;
        self.top_sort_count += 1
        self.finish_time[v] = self.top_sort_count
        self.sorting.append(v)

    def topsort(self):
        &#34;&#34;&#34;
        Performs a topological sorting of the graph, classifying
        all edges as (1) tree, (2) forward, (3) back or (4) cross
        edges in the process.

        see Cormen 2001 for details
        &#34;&#34;&#34;
        self.sorting = []
        self.parent = {}
        self.start_time = {}
        self.finish_time = {}
        self.edge_classes = {}
        self.top_sort_count = 0
        self.is_acyclic = True
        for v in self.nodes:
            if v not in self.parent:
                self.dfs_visit(v)
        self.sorting.reverse()

    def make_acyclic(self):
        &#34;&#34;&#34;Removes all back-links from the graph to make it acyclic, then performs another
        topological sorting of the DAG
        &#34;&#34;&#34;
        if self.is_acyclic is None:
            self.topsort()
        removed_links = 0
        if not self.is_acyclic:
            # Remove all back links
            for e in list(self.edge_classes):
                if self.edge_classes[e] == &#39;back&#39;:
                    self.remove_edge(*e)
                    removed_links += 1
            self.topsort()
            assert self.is_acyclic, &#34;Error: make_acyclic did not generate acyclic graph!&#34;
            Log.add(&#39;Removed &#39; + str(removed_links) +
                    &#39; back links to make graph acyclic&#39;, Severity.INFO)

    def summary(self):
        &#34;&#34;&#34;
        Returns a string representation of this directed acyclic graph
        &#34;&#34;&#34;

        summary = &#39;Directed Acyclic Graph&#39;
        summary += &#39;\n&#39;
        summary += &#39;Nodes:\t\t&#39; + str(len(self.nodes)) + &#39;\n&#39;
        summary += &#39;Roots:\t\t&#39; + str(len(self.roots)) + &#39;\n&#39;
        summary += &#39;Leaves:\t\t&#39; + str(len(self.leafs)) + &#39;\n&#39;
        summary += &#39;Links:\t\t&#39; + str(len(self.edges)) + &#39;\n&#39;
        summary += &#39;Acyclic:\t&#39; + str(self.is_acyclic) + &#39;\n&#39;
        return summary

    def isolate_nodes(self):
        &#34;&#34;&#34;Return a set of isolated nodes&#34;&#34;&#34;
        return self.leafs &amp; self.roots

    def __str__(self):
        &#34;&#34;&#34;
        Returns the default string representation of this object
        &#34;&#34;&#34;
        return self.summary()

    def add_node(self, node):
        &#34;&#34;&#34;
        Adds a node to a graph
        &#34;&#34;&#34;
        if node not in self.nodes:
            self.roots.add(node)
            self.leafs.add(node)
            super().add_node(node)

    def add_edge(self, source, target, **kwargs):
        &#34;&#34;&#34;
        Adds a directed edge to the graph
        &#34;&#34;&#34;

        if source not in self.nodes:
            self.add_node(source, **kwargs)
            self.roots.add(source)
        if target not in self.nodes:
            self.add_node(target, **kwargs)
            self.leafs.add(target)

        self.leafs.discard(source)
        self.roots.discard(target)
        super().add_edge(source, target)
        self.is_acyclic = None

    def remove_edge(self, source, target):
        &#34;&#34;&#34;remove an edge&#34;&#34;&#34;
        super().remove_edge(source, target)

        # if no more predecessors for the target then it becomes a root
        if not self.predecessors[target]:
            self.roots.add(target)

        # if no more successors for the source node then it becomes a leaf
        if not self.successors[source]:
            self.leafs.add(target)


    def write_file(self, filename, separator=&#39;,&#39;):
        &#34;&#34;&#34;Writes a dag as an adjaceny list to file

        Parameters
        ----------
        filename
        sep

        Returns
        -------
        dag
        &#34;&#34;&#34;
        with open(filename, &#39;w&#39;) as file:
            for edge in self.edges:
                file.write(separator.join(edge)+&#39;\n&#39;)

    @classmethod
    def read_file(cls, filename, separator=&#39;,&#39;, maxlines=None, mapping=None, header=False):
        &#34;&#34;&#34;
        Reads a directed acyclic graph from a file
        containing an edge list of the form

        source,target

        where &#39;,&#39; can be an arbitrary separator character
        &#34;&#34;&#34;
        with open(filename, &#39;r&#39;) as f:
            edges = []

            if mapping is not None:
                Log.add(&#39;Filtering mapped edges&#39;)

            Log.add(&#39;Reading edge list ...&#39;)

            if header:  # Read header
                f.readline()
            for i, line in enumerate(f):
                if maxlines and i &gt; maxlines:
                    break
                fields = line.rstrip().split(separator)
                try:
                    if mapping is None or (fields[0] in mapping and fields[1] in mapping):
                        edges.append((fields[0], fields[1]))

                except (IndexError, ValueError):  # pragma: no cover
                    msg = &#39;Ignoring malformed data in &#39; \
                          &#39;line {}: &#34;{}&#34;&#39;.format((i+header), line.strip())
                    Log.add(msg, Severity.WARNING)

        return cls(edges=edges)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="pathpy.classes.dag.DAG"><code class="flex name class">
<span>class <span class="ident">DAG</span></span>
<span>(</span><span><small>ancestors:</small> <a title="pathpy.classes.network.Network" href="network.html#pathpy.classes.network.Network">Network</a>)</span>
</code></dt>
<dd>
<section class="desc"><p>A directed acyclic graph (DAG) which
can be used to generate pathway statistics.</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">class DAG(Network):
    &#34;&#34;&#34;
        A directed acyclic graph (DAG) which
        can be used to generate pathway statistics.
    &#34;&#34;&#34;

    def __init__(self, edges=None):
        &#34;&#34;&#34;
        Constructs a directed acyclic graph from an edge list
        &#34;&#34;&#34;

        super().__init__(directed=True)

        # Whether or not this graph is acyclic. None indicates that it is unknown
        self.is_acyclic = None

        # list of topologically sorted nodes
        self.sorting = []

        # Set of nodes with no incoming edges
        self.roots = set()

        # Set of nodes with no outgoing edges
        self.leafs = set()

        if edges is not None:
            self.add_edges(edges)

        # placeholder properties for topological sort
        self.parent = {}
        self.start_time = {}
        self.finish_time = {}
        self.edge_classes = {}
        self.top_sort_count = 0


    @classmethod
    def from_node_activity_sequence(cls, sequence, self_loops=True, connect_prior=0):
        &#34;&#34;&#34;
        Generates a directed acyclic graph from a sequence of node
        activations, where each activation is assumed to be influenced
        by previous activations. This is useful to extract a
        directed acyclic graph, e.g., from a sequence of user activities
        in a communication forum. The sequence of interactions is taken into
        account in the generation of the DAG. The number of prior activations to
        each node will be linked can be customized using the connect_prior parameter.
        For the default 0 (which means connect to all prior activations), a sequence
        [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;a&#39;] will result in a dag (0,1), (0,2), (0,3), (1,2), (1,3), (2,3).
        The returned node_map maps the nodes in the DAG to the actual nodes, i.e. in the example
        node_map = { &#39;0&#39;: &#39;a&#39;, &#39;1&#39;: &#39;b&#39;, &#39;2&#39;: c, &#39;3&#39;: a}.

        Parameter:
        ----------
        sequence: iterable
            any iterable containing a sequence of string node names
        self_loops: bool
            whether or not to consider links linking nodes to themselves, i.e. whether
            to consider an edge (x, y) in the dag where node_map[x] == node_map[y]
        connect_prior: bool
            to how many prior nodes each node shall be linked. For a value of 1, a chain 
            will be generated, for 2 a lattice where each node is connected to two previous
            nodes is generated. For the default 0 each node is connected to all prior nodes.
        &#34;&#34;&#34;
        dag = cls()

        # dictionary that maps nodes in dag to actual nodes
        node_map = {}

        i = 0
        for v in sequence:
            name = str(i)
            node_map[name] = v
            dag.add_node(name)
            if connect_prior == 0:
                m = i
            else:
                m = min(connect_prior, i)
            for j in range(i-m, i):
                if self_loops or node_map[str(j)] != node_map[name]:
                    dag.add_edge(str(j), name)            
            i += 1
        return dag, node_map


    @classmethod
    def from_temporal_network(cls, tempnet, delta=1):
        &#34;&#34;&#34;
        Creates a time-unfolded directed acyclic graph from a
        temporal network for a given maximum time difference delta.

        Parameters
        ----------
        tempnet: pp.TemporalNetwork
            The temporal network instance to use for the DAG generation.

        delta: int
            The maximum time difference t&#39;- t between two time-stamped edges
            (a,b,t) and (b,c,t&#39;) up to which a causal path (a, b, c) is a
            created in the DAG

        &#34;&#34;&#34;
        dag = cls()

        # dictionary that maps time-unfolded nodes to actual nodes
        node_map = {}

        for (v, w, t) in tempnet.tedges:
            # create time-unfolded nodes v_t and w_{t+1}
            v_t = &#34;{0}_{1}&#34;.format(v, t)
            node_map[v_t] = v

            # create one time-unfolded link for all delta in [1, delta]
            # this implies that for delta = 2 and an edge (a,b,1) two 
            # time-unfolded links (a_1, b_2) and (a_1, b_3) will be created
            for x in range(1, int(delta)+1):
                w_t = &#34;{0}_{1}&#34;.format(w, t+x)
                node_map[w_t] = w
                dag.add_edge(v_t, w_t)

        return dag, node_map


    def add_edges(self, edges):
        &#34;&#34;&#34;Add a list of edges

        Parameters
        ----------
        edges: list
            a list of edges [(s_1, t_1), (s_1, t_2), ...]

        &#34;&#34;&#34;
        self_loops = 0
        redundant_edges = 0
        for e in edges:
            is_redundant = False
            has_self_loop = False
            if e[0] == e[1]:
                has_self_loop = True
                self_loops += 1
            if (e[0], e[1]) in self.edges:
                is_redundant = True
                redundant_edges += 1
            if not has_self_loop and not is_redundant:
                self.add_edge(e[0], e[1])
        if self_loops &gt; 0:
            Log.add(&#39;Warning: omitted %d self-loops&#39; % self_loops, Severity.WARNING)
        if redundant_edges &gt; 0:
            Log.add(&#39;Warning: omitted %d redundant edges&#39; % redundant_edges,
                    Severity.WARNING)

    def routes_from_node(self, v, node_mapping=None):
        &#34;&#34;&#34;
        Constructs all paths from node v to any leaf nodes

        Parameters
        ----------
        v:
            node from which to start
        node_mapping: dict
            an optional mapping from node to a different set.

        Returns
        -------
        list
            a list of lists, where each list contains one path from the source
            node v until a leaf node is reached
        &#34;&#34;&#34;
        # Collect temporary paths, indexed by the target node
        temp_paths = defaultdict(list)
        temp_paths[v] = [[v]]

        # set of unprocessed nodes
        queue = {v}

        while queue:
            # take one unprocessed node
            x = queue.pop()

            # successors of x expand all temporary
            # paths, currently ending in x
            if self.successors[x]:
                for w in self.successors[x]:
                    for p in temp_paths[x]:
                        temp_paths[w].append(p + [w])
                    queue.add(w)
                del temp_paths[x]

        # flatten list
        final_paths = []
        for possible_paths in temp_paths.values():
            for path in possible_paths:
                if node_mapping:
                    path = [node_mapping[k] for k in path]
                final_paths.append(path)

        return final_paths

    def routes_to_node(self, v, node_mapping=None):
        &#34;&#34;&#34;
        Constructs all paths to node v from any root node

        Parameters
        ----------
        v:
            node from which to start
        node_mapping: dict
            an optional mapping from node to a different set.

        Returns
        -------
        list
            a list of lists, where each list contains one path from the source
            node v until a leaf node is reached
        &#34;&#34;&#34;
        # Collect temporary paths, indexed by the target node
        temp_paths = defaultdict(list)
        temp_paths[v] = [[v]]

        # set of unprocessed nodes
        queue = {v}

        while queue:
            # take one unprocessed node
            x = queue.pop()

            # successors of x expand all temporary
            # paths, currently ending in x
            if self.predecessors[x]:
                for w in self.predecessors[x]:
                    for p in temp_paths[x]:
                        temp_paths[w].append(p + [w])
                    queue.add(w)
                del temp_paths[x]

        # flatten list
        final_paths = []
        for possible_paths in temp_paths.values():
            for path in possible_paths:
                path = list(reversed(path))
                if node_mapping:
                    path = [node_mapping[k] for k in path]
                final_paths.append(path)

        return final_paths

    def dfs_visit(self, v, parent=None):
        &#34;&#34;&#34;Recursively visits nodes in the graph, classifying edges as (1) tree, (2)
        forward, (3) back or (4) cross edges.

        Parameters
        ----------
        v:
            node to be visited
        parent:
            the parent of this node (None for nodes) with no parents
        &#34;&#34;&#34;
        self.parent[v] = parent
        self.top_sort_count += 1
        self.start_time[v] = self.top_sort_count
        if parent:
            self.edge_classes[(parent, v)] = &#39;tree&#39;

        for w in self.successors[v]:
            if w not in self.parent:
                self.dfs_visit(w, v)
            elif w not in self.finish_time:
                self.edge_classes[(v, w)] = &#39;back&#39;
                self.is_acyclic = False
            elif self.start_time[v] &lt; self.start_time[w]:
                self.edge_classes[(v, w)] = &#39;forward&#39;
            else:
                self.edge_classes[(v, w)] = &#39;cross&#39;
        self.top_sort_count += 1
        self.finish_time[v] = self.top_sort_count
        self.sorting.append(v)

    def topsort(self):
        &#34;&#34;&#34;
        Performs a topological sorting of the graph, classifying
        all edges as (1) tree, (2) forward, (3) back or (4) cross
        edges in the process.

        see Cormen 2001 for details
        &#34;&#34;&#34;
        self.sorting = []
        self.parent = {}
        self.start_time = {}
        self.finish_time = {}
        self.edge_classes = {}
        self.top_sort_count = 0
        self.is_acyclic = True
        for v in self.nodes:
            if v not in self.parent:
                self.dfs_visit(v)
        self.sorting.reverse()

    def make_acyclic(self):
        &#34;&#34;&#34;Removes all back-links from the graph to make it acyclic, then performs another
        topological sorting of the DAG
        &#34;&#34;&#34;
        if self.is_acyclic is None:
            self.topsort()
        removed_links = 0
        if not self.is_acyclic:
            # Remove all back links
            for e in list(self.edge_classes):
                if self.edge_classes[e] == &#39;back&#39;:
                    self.remove_edge(*e)
                    removed_links += 1
            self.topsort()
            assert self.is_acyclic, &#34;Error: make_acyclic did not generate acyclic graph!&#34;
            Log.add(&#39;Removed &#39; + str(removed_links) +
                    &#39; back links to make graph acyclic&#39;, Severity.INFO)

    def summary(self):
        &#34;&#34;&#34;
        Returns a string representation of this directed acyclic graph
        &#34;&#34;&#34;

        summary = &#39;Directed Acyclic Graph&#39;
        summary += &#39;\n&#39;
        summary += &#39;Nodes:\t\t&#39; + str(len(self.nodes)) + &#39;\n&#39;
        summary += &#39;Roots:\t\t&#39; + str(len(self.roots)) + &#39;\n&#39;
        summary += &#39;Leaves:\t\t&#39; + str(len(self.leafs)) + &#39;\n&#39;
        summary += &#39;Links:\t\t&#39; + str(len(self.edges)) + &#39;\n&#39;
        summary += &#39;Acyclic:\t&#39; + str(self.is_acyclic) + &#39;\n&#39;
        return summary

    def isolate_nodes(self):
        &#34;&#34;&#34;Return a set of isolated nodes&#34;&#34;&#34;
        return self.leafs &amp; self.roots

    def __str__(self):
        &#34;&#34;&#34;
        Returns the default string representation of this object
        &#34;&#34;&#34;
        return self.summary()

    def add_node(self, node):
        &#34;&#34;&#34;
        Adds a node to a graph
        &#34;&#34;&#34;
        if node not in self.nodes:
            self.roots.add(node)
            self.leafs.add(node)
            super().add_node(node)

    def add_edge(self, source, target, **kwargs):
        &#34;&#34;&#34;
        Adds a directed edge to the graph
        &#34;&#34;&#34;

        if source not in self.nodes:
            self.add_node(source, **kwargs)
            self.roots.add(source)
        if target not in self.nodes:
            self.add_node(target, **kwargs)
            self.leafs.add(target)

        self.leafs.discard(source)
        self.roots.discard(target)
        super().add_edge(source, target)
        self.is_acyclic = None

    def remove_edge(self, source, target):
        &#34;&#34;&#34;remove an edge&#34;&#34;&#34;
        super().remove_edge(source, target)

        # if no more predecessors for the target then it becomes a root
        if not self.predecessors[target]:
            self.roots.add(target)

        # if no more successors for the source node then it becomes a leaf
        if not self.successors[source]:
            self.leafs.add(target)


    def write_file(self, filename, separator=&#39;,&#39;):
        &#34;&#34;&#34;Writes a dag as an adjaceny list to file

        Parameters
        ----------
        filename
        sep

        Returns
        -------
        dag
        &#34;&#34;&#34;
        with open(filename, &#39;w&#39;) as file:
            for edge in self.edges:
                file.write(separator.join(edge)+&#39;\n&#39;)

    @classmethod
    def read_file(cls, filename, separator=&#39;,&#39;, maxlines=None, mapping=None, header=False):
        &#34;&#34;&#34;
        Reads a directed acyclic graph from a file
        containing an edge list of the form

        source,target

        where &#39;,&#39; can be an arbitrary separator character
        &#34;&#34;&#34;
        with open(filename, &#39;r&#39;) as f:
            edges = []

            if mapping is not None:
                Log.add(&#39;Filtering mapped edges&#39;)

            Log.add(&#39;Reading edge list ...&#39;)

            if header:  # Read header
                f.readline()
            for i, line in enumerate(f):
                if maxlines and i &gt; maxlines:
                    break
                fields = line.rstrip().split(separator)
                try:
                    if mapping is None or (fields[0] in mapping and fields[1] in mapping):
                        edges.append((fields[0], fields[1]))

                except (IndexError, ValueError):  # pragma: no cover
                    msg = &#39;Ignoring malformed data in &#39; \
                          &#39;line {}: &#34;{}&#34;&#39;.format((i+header), line.strip())
                    Log.add(msg, Severity.WARNING)

        return cls(edges=edges)</code></pre>
</details>
<h3>Static methods</h3>
<dl>
<dt id="pathpy.classes.dag.DAG.from_node_activity_sequence"><code class="name flex">
<span>def <span class="ident">from_node_activity_sequence</span></span>(<span>cls, sequence, self_loops=True, connect_prior=0)</span>
</code></dt>
<dd>
<section class="desc"><p>Generates a directed acyclic graph from a sequence of node
activations, where each activation is assumed to be influenced
by previous activations. This is useful to extract a
directed acyclic graph, e.g., from a sequence of user activities
in a communication forum. The sequence of interactions is taken into
account in the generation of the DAG. The number of prior activations to
each node will be linked can be customized using the connect_prior parameter.
For the default 0 (which means connect to all prior activations), a sequence
['a', 'b', 'c', 'a'] will result in a dag (0,1), (0,2), (0,3), (1,2), (1,3), (2,3).
The returned node_map maps the nodes in the DAG to the actual nodes, i.e. in the example
node_map = { '0': 'a', '1': 'b', '2': c, '3': a}.</p>
<h2 id="parameter">Parameter:</h2>
<dl>
<dt><strong><code>sequence</code></strong> :&ensp;<code>iterable</code></dt>
<dd>any iterable containing a sequence of string node names</dd>
<dt><strong><code>self_loops</code></strong> :&ensp;<code>bool</code></dt>
<dd>whether or not to consider links linking nodes to themselves, i.e. whether
to consider an edge (x, y) in the dag where node_map[x] == node_map[y]</dd>
<dt><strong><code>connect_prior</code></strong> :&ensp;<code>bool</code></dt>
<dd>to how many prior nodes each node shall be linked. For a value of 1, a chain
will be generated, for 2 a lattice where each node is connected to two previous
nodes is generated. For the default 0 each node is connected to all prior nodes.</dd>
</dl></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">@classmethod
def from_node_activity_sequence(cls, sequence, self_loops=True, connect_prior=0):
    &#34;&#34;&#34;
    Generates a directed acyclic graph from a sequence of node
    activations, where each activation is assumed to be influenced
    by previous activations. This is useful to extract a
    directed acyclic graph, e.g., from a sequence of user activities
    in a communication forum. The sequence of interactions is taken into
    account in the generation of the DAG. The number of prior activations to
    each node will be linked can be customized using the connect_prior parameter.
    For the default 0 (which means connect to all prior activations), a sequence
    [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;a&#39;] will result in a dag (0,1), (0,2), (0,3), (1,2), (1,3), (2,3).
    The returned node_map maps the nodes in the DAG to the actual nodes, i.e. in the example
    node_map = { &#39;0&#39;: &#39;a&#39;, &#39;1&#39;: &#39;b&#39;, &#39;2&#39;: c, &#39;3&#39;: a}.

    Parameter:
    ----------
    sequence: iterable
        any iterable containing a sequence of string node names
    self_loops: bool
        whether or not to consider links linking nodes to themselves, i.e. whether
        to consider an edge (x, y) in the dag where node_map[x] == node_map[y]
    connect_prior: bool
        to how many prior nodes each node shall be linked. For a value of 1, a chain 
        will be generated, for 2 a lattice where each node is connected to two previous
        nodes is generated. For the default 0 each node is connected to all prior nodes.
    &#34;&#34;&#34;
    dag = cls()

    # dictionary that maps nodes in dag to actual nodes
    node_map = {}

    i = 0
    for v in sequence:
        name = str(i)
        node_map[name] = v
        dag.add_node(name)
        if connect_prior == 0:
            m = i
        else:
            m = min(connect_prior, i)
        for j in range(i-m, i):
            if self_loops or node_map[str(j)] != node_map[name]:
                dag.add_edge(str(j), name)            
        i += 1
    return dag, node_map</code></pre>
</details>
</dd>
<dt id="pathpy.classes.dag.DAG.from_temporal_network"><code class="name flex">
<span>def <span class="ident">from_temporal_network</span></span>(<span>cls, tempnet, delta=1)</span>
</code></dt>
<dd>
<section class="desc"><p>Creates a time-unfolded directed acyclic graph from a
temporal network for a given maximum time difference delta.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>tempnet</code></strong> :&ensp;<code>pp.TemporalNetwork</code></dt>
<dd>The temporal network instance to use for the DAG generation.</dd>
<dt><strong><code>delta</code></strong> :&ensp;<code>int</code></dt>
<dd>The maximum time difference t'- t between two time-stamped edges
(a,b,t) and (b,c,t') up to which a causal path (a, b, c) is a
created in the DAG</dd>
</dl></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">@classmethod
def from_temporal_network(cls, tempnet, delta=1):
    &#34;&#34;&#34;
    Creates a time-unfolded directed acyclic graph from a
    temporal network for a given maximum time difference delta.

    Parameters
    ----------
    tempnet: pp.TemporalNetwork
        The temporal network instance to use for the DAG generation.

    delta: int
        The maximum time difference t&#39;- t between two time-stamped edges
        (a,b,t) and (b,c,t&#39;) up to which a causal path (a, b, c) is a
        created in the DAG

    &#34;&#34;&#34;
    dag = cls()

    # dictionary that maps time-unfolded nodes to actual nodes
    node_map = {}

    for (v, w, t) in tempnet.tedges:
        # create time-unfolded nodes v_t and w_{t+1}
        v_t = &#34;{0}_{1}&#34;.format(v, t)
        node_map[v_t] = v

        # create one time-unfolded link for all delta in [1, delta]
        # this implies that for delta = 2 and an edge (a,b,1) two 
        # time-unfolded links (a_1, b_2) and (a_1, b_3) will be created
        for x in range(1, int(delta)+1):
            w_t = &#34;{0}_{1}&#34;.format(w, t+x)
            node_map[w_t] = w
            dag.add_edge(v_t, w_t)

    return dag, node_map</code></pre>
</details>
</dd>
<dt id="pathpy.classes.dag.DAG.read_file"><code class="name flex">
<span>def <span class="ident">read_file</span></span>(<span>cls, filename, separator=&#39;,&#39;, maxlines=None, mapping=None, header=False)</span>
</code></dt>
<dd>
<section class="desc"><p>Reads a directed acyclic graph from a file
containing an edge list of the form</p>
<p>source,target</p>
<p>where ',' can be an arbitrary separator character</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">@classmethod
def read_file(cls, filename, separator=&#39;,&#39;, maxlines=None, mapping=None, header=False):
    &#34;&#34;&#34;
    Reads a directed acyclic graph from a file
    containing an edge list of the form

    source,target

    where &#39;,&#39; can be an arbitrary separator character
    &#34;&#34;&#34;
    with open(filename, &#39;r&#39;) as f:
        edges = []

        if mapping is not None:
            Log.add(&#39;Filtering mapped edges&#39;)

        Log.add(&#39;Reading edge list ...&#39;)

        if header:  # Read header
            f.readline()
        for i, line in enumerate(f):
            if maxlines and i &gt; maxlines:
                break
            fields = line.rstrip().split(separator)
            try:
                if mapping is None or (fields[0] in mapping and fields[1] in mapping):
                    edges.append((fields[0], fields[1]))

            except (IndexError, ValueError):  # pragma: no cover
                msg = &#39;Ignoring malformed data in &#39; \
                      &#39;line {}: &#34;{}&#34;&#39;.format((i+header), line.strip())
                Log.add(msg, Severity.WARNING)

    return cls(edges=edges)</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="pathpy.classes.dag.DAG.__init__"><code class="name flex">
<span>def <span class="ident">__init__</span></span>(<span>self, edges=None)</span>
</code></dt>
<dd>
<section class="desc"><p>Constructs a directed acyclic graph from an edge list</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def __init__(self, edges=None):
    &#34;&#34;&#34;
    Constructs a directed acyclic graph from an edge list
    &#34;&#34;&#34;

    super().__init__(directed=True)

    # Whether or not this graph is acyclic. None indicates that it is unknown
    self.is_acyclic = None

    # list of topologically sorted nodes
    self.sorting = []

    # Set of nodes with no incoming edges
    self.roots = set()

    # Set of nodes with no outgoing edges
    self.leafs = set()

    if edges is not None:
        self.add_edges(edges)

    # placeholder properties for topological sort
    self.parent = {}
    self.start_time = {}
    self.finish_time = {}
    self.edge_classes = {}
    self.top_sort_count = 0</code></pre>
</details>
</dd>
<dt id="pathpy.classes.dag.DAG.add_edge"><code class="name flex">
<span>def <span class="ident">add_edge</span></span>(<span>self, source, target, **kwargs)</span>
</code></dt>
<dd>
<section class="desc"><p>Adds a directed edge to the graph</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def add_edge(self, source, target, **kwargs):
    &#34;&#34;&#34;
    Adds a directed edge to the graph
    &#34;&#34;&#34;

    if source not in self.nodes:
        self.add_node(source, **kwargs)
        self.roots.add(source)
    if target not in self.nodes:
        self.add_node(target, **kwargs)
        self.leafs.add(target)

    self.leafs.discard(source)
    self.roots.discard(target)
    super().add_edge(source, target)
    self.is_acyclic = None</code></pre>
</details>
</dd>
<dt id="pathpy.classes.dag.DAG.add_edges"><code class="name flex">
<span>def <span class="ident">add_edges</span></span>(<span>self, edges)</span>
</code></dt>
<dd>
<section class="desc"><p>Add a list of edges</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>edges</code></strong> :&ensp;<code>list</code></dt>
<dd>a list of edges [(s_1, t_1), (s_1, t_2), &hellip;]</dd>
</dl></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def add_edges(self, edges):
    &#34;&#34;&#34;Add a list of edges

    Parameters
    ----------
    edges: list
        a list of edges [(s_1, t_1), (s_1, t_2), ...]

    &#34;&#34;&#34;
    self_loops = 0
    redundant_edges = 0
    for e in edges:
        is_redundant = False
        has_self_loop = False
        if e[0] == e[1]:
            has_self_loop = True
            self_loops += 1
        if (e[0], e[1]) in self.edges:
            is_redundant = True
            redundant_edges += 1
        if not has_self_loop and not is_redundant:
            self.add_edge(e[0], e[1])
    if self_loops &gt; 0:
        Log.add(&#39;Warning: omitted %d self-loops&#39; % self_loops, Severity.WARNING)
    if redundant_edges &gt; 0:
        Log.add(&#39;Warning: omitted %d redundant edges&#39; % redundant_edges,
                Severity.WARNING)</code></pre>
</details>
</dd>
<dt id="pathpy.classes.dag.DAG.add_node"><code class="name flex">
<span>def <span class="ident">add_node</span></span>(<span>self, node)</span>
</code></dt>
<dd>
<section class="desc"><p>Adds a node to a graph</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def add_node(self, node):
    &#34;&#34;&#34;
    Adds a node to a graph
    &#34;&#34;&#34;
    if node not in self.nodes:
        self.roots.add(node)
        self.leafs.add(node)
        super().add_node(node)</code></pre>
</details>
</dd>
<dt id="pathpy.classes.dag.DAG.dfs_visit"><code class="name flex">
<span>def <span class="ident">dfs_visit</span></span>(<span>self, v, parent=None)</span>
</code></dt>
<dd>
<section class="desc"><p>Recursively visits nodes in the graph, classifying edges as (1) tree, (2)
forward, (3) back or (4) cross edges.</p>
<h2 id="parameters">Parameters</h2>
<p>v:
node to be visited
parent:
the parent of this node (None for nodes) with no parents</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def dfs_visit(self, v, parent=None):
    &#34;&#34;&#34;Recursively visits nodes in the graph, classifying edges as (1) tree, (2)
    forward, (3) back or (4) cross edges.

    Parameters
    ----------
    v:
        node to be visited
    parent:
        the parent of this node (None for nodes) with no parents
    &#34;&#34;&#34;
    self.parent[v] = parent
    self.top_sort_count += 1
    self.start_time[v] = self.top_sort_count
    if parent:
        self.edge_classes[(parent, v)] = &#39;tree&#39;

    for w in self.successors[v]:
        if w not in self.parent:
            self.dfs_visit(w, v)
        elif w not in self.finish_time:
            self.edge_classes[(v, w)] = &#39;back&#39;
            self.is_acyclic = False
        elif self.start_time[v] &lt; self.start_time[w]:
            self.edge_classes[(v, w)] = &#39;forward&#39;
        else:
            self.edge_classes[(v, w)] = &#39;cross&#39;
    self.top_sort_count += 1
    self.finish_time[v] = self.top_sort_count
    self.sorting.append(v)</code></pre>
</details>
</dd>
<dt id="pathpy.classes.dag.DAG.isolate_nodes"><code class="name flex">
<span>def <span class="ident">isolate_nodes</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>Return a set of isolated nodes</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def isolate_nodes(self):
    &#34;&#34;&#34;Return a set of isolated nodes&#34;&#34;&#34;
    return self.leafs &amp; self.roots</code></pre>
</details>
</dd>
<dt id="pathpy.classes.dag.DAG.make_acyclic"><code class="name flex">
<span>def <span class="ident">make_acyclic</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>Removes all back-links from the graph to make it acyclic, then performs another
topological sorting of the DAG</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def make_acyclic(self):
    &#34;&#34;&#34;Removes all back-links from the graph to make it acyclic, then performs another
    topological sorting of the DAG
    &#34;&#34;&#34;
    if self.is_acyclic is None:
        self.topsort()
    removed_links = 0
    if not self.is_acyclic:
        # Remove all back links
        for e in list(self.edge_classes):
            if self.edge_classes[e] == &#39;back&#39;:
                self.remove_edge(*e)
                removed_links += 1
        self.topsort()
        assert self.is_acyclic, &#34;Error: make_acyclic did not generate acyclic graph!&#34;
        Log.add(&#39;Removed &#39; + str(removed_links) +
                &#39; back links to make graph acyclic&#39;, Severity.INFO)</code></pre>
</details>
</dd>
<dt id="pathpy.classes.dag.DAG.remove_edge"><code class="name flex">
<span>def <span class="ident">remove_edge</span></span>(<span>self, source, target)</span>
</code></dt>
<dd>
<section class="desc"><p>remove an edge</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def remove_edge(self, source, target):
    &#34;&#34;&#34;remove an edge&#34;&#34;&#34;
    super().remove_edge(source, target)

    # if no more predecessors for the target then it becomes a root
    if not self.predecessors[target]:
        self.roots.add(target)

    # if no more successors for the source node then it becomes a leaf
    if not self.successors[source]:
        self.leafs.add(target)</code></pre>
</details>
</dd>
<dt id="pathpy.classes.dag.DAG.routes_from_node"><code class="name flex">
<span>def <span class="ident">routes_from_node</span></span>(<span>self, v, node_mapping=None)</span>
</code></dt>
<dd>
<section class="desc"><p>Constructs all paths from node v to any leaf nodes</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt>v:</dt>
<dt>node from which to start</dt>
<dt><strong><code>node_mapping</code></strong> :&ensp;<code>dict</code></dt>
<dd>an optional mapping from node to a different set.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>list</code></strong></dt>
<dd>a list of lists, where each list contains one path from the source
node v until a leaf node is reached</dd>
</dl></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def routes_from_node(self, v, node_mapping=None):
    &#34;&#34;&#34;
    Constructs all paths from node v to any leaf nodes

    Parameters
    ----------
    v:
        node from which to start
    node_mapping: dict
        an optional mapping from node to a different set.

    Returns
    -------
    list
        a list of lists, where each list contains one path from the source
        node v until a leaf node is reached
    &#34;&#34;&#34;
    # Collect temporary paths, indexed by the target node
    temp_paths = defaultdict(list)
    temp_paths[v] = [[v]]

    # set of unprocessed nodes
    queue = {v}

    while queue:
        # take one unprocessed node
        x = queue.pop()

        # successors of x expand all temporary
        # paths, currently ending in x
        if self.successors[x]:
            for w in self.successors[x]:
                for p in temp_paths[x]:
                    temp_paths[w].append(p + [w])
                queue.add(w)
            del temp_paths[x]

    # flatten list
    final_paths = []
    for possible_paths in temp_paths.values():
        for path in possible_paths:
            if node_mapping:
                path = [node_mapping[k] for k in path]
            final_paths.append(path)

    return final_paths</code></pre>
</details>
</dd>
<dt id="pathpy.classes.dag.DAG.routes_to_node"><code class="name flex">
<span>def <span class="ident">routes_to_node</span></span>(<span>self, v, node_mapping=None)</span>
</code></dt>
<dd>
<section class="desc"><p>Constructs all paths to node v from any root node</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt>v:</dt>
<dt>node from which to start</dt>
<dt><strong><code>node_mapping</code></strong> :&ensp;<code>dict</code></dt>
<dd>an optional mapping from node to a different set.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>list</code></strong></dt>
<dd>a list of lists, where each list contains one path from the source
node v until a leaf node is reached</dd>
</dl></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def routes_to_node(self, v, node_mapping=None):
    &#34;&#34;&#34;
    Constructs all paths to node v from any root node

    Parameters
    ----------
    v:
        node from which to start
    node_mapping: dict
        an optional mapping from node to a different set.

    Returns
    -------
    list
        a list of lists, where each list contains one path from the source
        node v until a leaf node is reached
    &#34;&#34;&#34;
    # Collect temporary paths, indexed by the target node
    temp_paths = defaultdict(list)
    temp_paths[v] = [[v]]

    # set of unprocessed nodes
    queue = {v}

    while queue:
        # take one unprocessed node
        x = queue.pop()

        # successors of x expand all temporary
        # paths, currently ending in x
        if self.predecessors[x]:
            for w in self.predecessors[x]:
                for p in temp_paths[x]:
                    temp_paths[w].append(p + [w])
                queue.add(w)
            del temp_paths[x]

    # flatten list
    final_paths = []
    for possible_paths in temp_paths.values():
        for path in possible_paths:
            path = list(reversed(path))
            if node_mapping:
                path = [node_mapping[k] for k in path]
            final_paths.append(path)

    return final_paths</code></pre>
</details>
</dd>
<dt id="pathpy.classes.dag.DAG.summary"><code class="name flex">
<span>def <span class="ident">summary</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>Returns a string representation of this directed acyclic graph</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def summary(self):
    &#34;&#34;&#34;
    Returns a string representation of this directed acyclic graph
    &#34;&#34;&#34;

    summary = &#39;Directed Acyclic Graph&#39;
    summary += &#39;\n&#39;
    summary += &#39;Nodes:\t\t&#39; + str(len(self.nodes)) + &#39;\n&#39;
    summary += &#39;Roots:\t\t&#39; + str(len(self.roots)) + &#39;\n&#39;
    summary += &#39;Leaves:\t\t&#39; + str(len(self.leafs)) + &#39;\n&#39;
    summary += &#39;Links:\t\t&#39; + str(len(self.edges)) + &#39;\n&#39;
    summary += &#39;Acyclic:\t&#39; + str(self.is_acyclic) + &#39;\n&#39;
    return summary</code></pre>
</details>
</dd>
<dt id="pathpy.classes.dag.DAG.topsort"><code class="name flex">
<span>def <span class="ident">topsort</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>Performs a topological sorting of the graph, classifying
all edges as (1) tree, (2) forward, (3) back or (4) cross
edges in the process.</p>
<p>see Cormen 2001 for details</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def topsort(self):
    &#34;&#34;&#34;
    Performs a topological sorting of the graph, classifying
    all edges as (1) tree, (2) forward, (3) back or (4) cross
    edges in the process.

    see Cormen 2001 for details
    &#34;&#34;&#34;
    self.sorting = []
    self.parent = {}
    self.start_time = {}
    self.finish_time = {}
    self.edge_classes = {}
    self.top_sort_count = 0
    self.is_acyclic = True
    for v in self.nodes:
        if v not in self.parent:
            self.dfs_visit(v)
    self.sorting.reverse()</code></pre>
</details>
</dd>
<dt id="pathpy.classes.dag.DAG.write_file"><code class="name flex">
<span>def <span class="ident">write_file</span></span>(<span>self, filename, separator=&#39;,&#39;)</span>
</code></dt>
<dd>
<section class="desc"><p>Writes a dag as an adjaceny list to file</p>
<h2 id="parameters">Parameters</h2>
<p>filename
sep</p>
<h2 id="returns">Returns</h2>
<p>dag</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def write_file(self, filename, separator=&#39;,&#39;):
    &#34;&#34;&#34;Writes a dag as an adjaceny list to file

    Parameters
    ----------
    filename
    sep

    Returns
    -------
    dag
    &#34;&#34;&#34;
    with open(filename, &#39;w&#39;) as file:
        for edge in self.edges:
            file.write(separator.join(edge)+&#39;\n&#39;)</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="pathpy.classes.network.Network" href="network.html#pathpy.classes.network.Network">Network</a></b></code>:
<ul class="hlist">
<li><code><a title="pathpy.classes.network.Network.add_clique" href="network.html#pathpy.classes.network.Network.add_clique">add_clique</a></code></li>
<li><code><a title="pathpy.classes.network.Network.adjacency_matrix" href="network.html#pathpy.classes.network.Network.adjacency_matrix">adjacency_matrix</a></code></li>
<li><code><a title="pathpy.classes.network.Network.degrees" href="network.html#pathpy.classes.network.Network.degrees">degrees</a></code></li>
<li><code><a title="pathpy.classes.network.Network.ecount" href="network.html#pathpy.classes.network.Network.ecount">ecount</a></code></li>
<li><code><a title="pathpy.classes.network.Network.find_edges" href="network.html#pathpy.classes.network.Network.find_edges">find_edges</a></code></li>
<li><code><a title="pathpy.classes.network.Network.find_nodes" href="network.html#pathpy.classes.network.Network.find_nodes">find_nodes</a></code></li>
<li><code><a title="pathpy.classes.network.Network.from_paths" href="network.html#pathpy.classes.network.Network.from_paths">from_paths</a></code></li>
<li><code><a title="pathpy.classes.network.Network.from_sqlite" href="network.html#pathpy.classes.network.Network.from_sqlite">from_sqlite</a></code></li>
<li><code><a title="pathpy.classes.network.Network.laplacian_matrix" href="network.html#pathpy.classes.network.Network.laplacian_matrix">laplacian_matrix</a></code></li>
<li><code><a title="pathpy.classes.network.Network.leading_eigenvector" href="network.html#pathpy.classes.network.Network.leading_eigenvector">leading_eigenvector</a></code></li>
<li><code><a title="pathpy.classes.network.Network.ncount" href="network.html#pathpy.classes.network.Network.ncount">ncount</a></code></li>
<li><code><a title="pathpy.classes.network.Network.node_properties" href="network.html#pathpy.classes.network.Network.node_properties">node_properties</a></code></li>
<li><code><a title="pathpy.classes.network.Network.node_to_name_map" href="network.html#pathpy.classes.network.Network.node_to_name_map">node_to_name_map</a></code></li>
<li><code><a title="pathpy.classes.network.Network.remove_node" href="network.html#pathpy.classes.network.Network.remove_node">remove_node</a></code></li>
<li><code><a title="pathpy.classes.network.Network.to_undirected" href="network.html#pathpy.classes.network.Network.to_undirected">to_undirected</a></code></li>
<li><code><a title="pathpy.classes.network.Network.to_unweighted" href="network.html#pathpy.classes.network.Network.to_unweighted">to_unweighted</a></code></li>
<li><code><a title="pathpy.classes.network.Network.total_edge_weight" href="network.html#pathpy.classes.network.Network.total_edge_weight">total_edge_weight</a></code></li>
<li><code><a title="pathpy.classes.network.Network.transition_matrix" href="network.html#pathpy.classes.network.Network.transition_matrix">transition_matrix</a></code></li>
</ul>
</li>
</ul>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="pathpy.classes" href="index.html">pathpy.classes</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="pathpy.classes.dag.DAG" href="#pathpy.classes.dag.DAG">DAG</a></code></h4>
<ul class="">
<li><code><a title="pathpy.classes.dag.DAG.__init__" href="#pathpy.classes.dag.DAG.__init__">__init__</a></code></li>
<li><code><a title="pathpy.classes.dag.DAG.add_edge" href="#pathpy.classes.dag.DAG.add_edge">add_edge</a></code></li>
<li><code><a title="pathpy.classes.dag.DAG.add_edges" href="#pathpy.classes.dag.DAG.add_edges">add_edges</a></code></li>
<li><code><a title="pathpy.classes.dag.DAG.add_node" href="#pathpy.classes.dag.DAG.add_node">add_node</a></code></li>
<li><code><a title="pathpy.classes.dag.DAG.dfs_visit" href="#pathpy.classes.dag.DAG.dfs_visit">dfs_visit</a></code></li>
<li><code><a title="pathpy.classes.dag.DAG.from_node_activity_sequence" href="#pathpy.classes.dag.DAG.from_node_activity_sequence">from_node_activity_sequence</a></code></li>
<li><code><a title="pathpy.classes.dag.DAG.from_temporal_network" href="#pathpy.classes.dag.DAG.from_temporal_network">from_temporal_network</a></code></li>
<li><code><a title="pathpy.classes.dag.DAG.isolate_nodes" href="#pathpy.classes.dag.DAG.isolate_nodes">isolate_nodes</a></code></li>
<li><code><a title="pathpy.classes.dag.DAG.make_acyclic" href="#pathpy.classes.dag.DAG.make_acyclic">make_acyclic</a></code></li>
<li><code><a title="pathpy.classes.dag.DAG.read_file" href="#pathpy.classes.dag.DAG.read_file">read_file</a></code></li>
<li><code><a title="pathpy.classes.dag.DAG.remove_edge" href="#pathpy.classes.dag.DAG.remove_edge">remove_edge</a></code></li>
<li><code><a title="pathpy.classes.dag.DAG.routes_from_node" href="#pathpy.classes.dag.DAG.routes_from_node">routes_from_node</a></code></li>
<li><code><a title="pathpy.classes.dag.DAG.routes_to_node" href="#pathpy.classes.dag.DAG.routes_to_node">routes_to_node</a></code></li>
<li><code><a title="pathpy.classes.dag.DAG.summary" href="#pathpy.classes.dag.DAG.summary">summary</a></code></li>
<li><code><a title="pathpy.classes.dag.DAG.topsort" href="#pathpy.classes.dag.DAG.topsort">topsort</a></code></li>
<li><code><a title="pathpy.classes.dag.DAG.write_file" href="#pathpy.classes.dag.DAG.write_file">write_file</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.5.3</a>.</p>
</footer>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
<script>hljs.initHighlightingOnLoad()</script>
</body>
</html>