<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.5.3" />
<title>pathpy.algorithms.random_graphs API documentation</title>
<meta name="description" content="Algorithms to generate random graphs according to various models" />
<link href='https://cdnjs.cloudflare.com/ajax/libs/normalize/8.0.0/normalize.min.css' rel='stylesheet'>
<link href='https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/8.0.0/sanitize.min.css' rel='stylesheet'>
<link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/github.min.css" rel="stylesheet">
<style>.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{font-weight:bold}#index h4 + ul{margin-bottom:.6em}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.name small{font-weight:normal}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase;cursor:pointer}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}.admonition{padding:.1em .5em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title"><code>pathpy.algorithms.random_graphs</code> module</h1>
</header>
<section id="section-intro">
<p>Algorithms to generate random graphs according to various models</p>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">&#34;&#34;&#34;
Algorithms to generate random graphs according to various models
&#34;&#34;&#34;
# -*- coding: utf-8 -*-

#    pathpy is an OpenSource python package for the analysis of time series data
#    on networks using higher- and multi order graphical models.
#
#    Copyright (C) 2016-2018 Ingo Scholtes, ETH Zürich/Universität Zürich
#
#    This program is free software: you can redistribute it and/or modify
#    it under the terms of the GNU Affero General Public License as published
#    by the Free Software Foundation, either version 3 of the License, or
#    (at your option) any later version.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU Affero General Public License for more details.
#
#    You should have received a copy of the GNU Affero General Public License
#    along with this program. If not, see &lt;http://www.gnu.org/licenses/&gt;.
#
#    Contact the developer:
#
#    E-mail: scholtes@ifi.uzh.ch
#    Web:    http://www.ingoscholtes.net
from collections import defaultdict

import numpy as _np

from pathpy.utils import PathpyNotImplemented
from pathpy.classes import Network
from pathpy.classes import TemporalNetwork

__all__ = [&#39;is_graphic_sequence&#39;, &#39;molloy_reed&#39;, &#39;random_k_regular&#39;, &#39;erdoes_renyi_gnm&#39;,
           &#39;erdoes_renyi_gnp&#39;, &#39;watts_strogatz&#39;, &#39;barabasi_albert&#39;]


def is_graphic_sequence(degree_sequence, self_loops=False, multi_edges=False):
    r&#34;&#34;&#34;Checks whether a degree sequence is graphic, i.e. whether
    there exists an *undirected* graph without self-loops
    that has the given degree sequence. A graphic degree sequence is the
    precondition to apply the Molloy-Reed random graph generation.

    Note: this function does not support multi-edge networks with no self-loops.

    Parameters
    ----------
    degree_sequence: list or tuple
        the degree sequence for which to test the graphic property

    Returns
    -------
    bool
    &#34;&#34;&#34;
    assert not (not self_loops and multi_edges), &#39;Networks with multi_edges and no self_loops are not supported&#39;
    S = sum(degree_sequence)
    n = len(degree_sequence)

    # the sum of degrees must always be even (assuming self-loops are counted with degree of two)
    if S%2 != 0:
        return False

    # if multi-edges are allowed we are done
    if multi_edges:
        return True

    # use Behzad and Chartrand 1967, which shows that in a graphic degree
    # sequence at least one degree must occur twice (holds for networks without self_loops)
    if not self_loops and len(set(degree_sequence)) == len(degree_sequence):
        return False

    ordered_sequence = sorted(degree_sequence, reverse=True)

    # check necessary and sufficient condition given by Erdös and Gallai (1960)
    # see http://mathworld.wolfram.com/GraphicSequence.html
    # for networks with self-loops, we check the condition for all r&lt;=n
    # for networks without self-loops, we check the condition for all r&lt;=n-1

    if self_loops:
        max_r = n+1
    else:
        max_r = n

    for r in range(0, max_r):
        M = 0
        S = 0
        for i in range(0, r):
            S += ordered_sequence[i]
        for i in range(r, n):
            M += min(r+1, ordered_sequence[i])
        if S &gt; r * (r+1) + M:
            return False

    return True


def molloy_reed(degree_sequence, node_names=None, self_loops=True, multi_edges=False):
    &#34;&#34;&#34;
    Generates a random undirected network with a given degree sequence.
    The generated network is guaranteed to have the given degree sequence.
    Multiple edges are forbidden in the network generation. Raises an exception
    if the given degree sequence is not graphic, i.e. if no possible simple
    graph exisits with the desired degree sequence.

    Note: this function does not support the generation of multi-edge networks
    with no self-loops.

    Parameters:
    -----------
    degree_sequence: list or tuple
        The degree sequence of the randomly generated network. The degree
        sequence must have at least two entries. The sequence must be graphic,
        or an exception will be raised.
    node_names: list or tuple
        Node names to be used in the network creation. If None (default)
        nodes will be numbered from 0 to n-1, where n is the length of
        the degree sequence.
    self_loops: bol
        Whether or not to allow the generation of self_loops. Default is True.
    &#34;&#34;&#34;    

    assert is_graphic_sequence(degree_sequence, self_loops=self_loops, multi_edges=multi_edges), &#39;Error: degree sequence is not graphic&#39;

    n = len(degree_sequence)

    if node_names is None:
        node_names = [str(x) for x in range(n)]
    assert len(node_names) &gt;= n, &#39;Error: Number of node names not matching degree sequence length&#39;

    network = Network(directed=False)

    # generate a list with node stubs
    stubs = []
    for i in range(n):
        for j in range(degree_sequence[i]):
            stubs.append(str(node_names[i]))

    while len(stubs) &gt; 1:
        random_nodes = _np.random.choice(stubs, size=2, replace=False)
        (v, w) = (random_nodes[0], random_nodes[1])
        if (multi_edges or (v, w) not in network.edges) and (self_loops or v != w):
            weight = 1.0
            if (v, w) in network.edges:
                weight += network.edges[(v, w)][&#39;weight&#39;]
            network.add_edge(v, w, weight=weight)
            stubs.remove(v)
            if v != w: # ensures that self-loops are counted as degree 1
                stubs.remove(w)
        elif network.ecount() &gt; 0: # randomly remove edge
            edges = list(network.edges)
            edge = edges[_np.random.choice(len(edges))]
            network.remove_edge(edge[0], edge[1])
            stubs.append(edge[0])
            stubs.append(edge[1])
    return network


def random_k_regular(n, k, self_loops=True, node_names=None):
    &#34;&#34;&#34;
    Generates an undirected random k-regular network, i.e. a random
    network where all nodes have exactly degree k. A call to this
    function is equivalent to generating a random network with a 
    given degree sequence [k]*n.

    Parameters:
    -----------
    n: int
        The number of nodes in the generated network.
    k: int
        The degree of all nodes
    self_loops: bool
        Whether or not to allow self_loops in the network generation. 
        Default is True.
    node_names: list or sequence
        Node names to be used in the network creation. If None (default)
        nodes will be numbered from 0 to n-1.
    &#34;&#34;&#34;
    assert n*k%2 == 0, &#39;Error: parameters lead to non-graphic degree sequence.&#39;
    return molloy_reed([k]*n, node_names=node_names, self_loops=self_loops)


def erdoes_renyi_gnm(n, m, node_names=None, self_loops=True, directed=False, temporal=False):
    &#34;&#34;&#34;
    &#34;&#34;&#34;
    if node_names is None:
        node_names = [str(x) for x in range(n)]

    assert len(node_names) &gt;= n, &#39;Error: Number of node names not matching degree sequence length&#39;

    if not temporal:
        network = Network(directed=directed)
    else:
        network = TemporalNetwork()

    # generate nodes
    if not temporal:
        for i in range(n):
            network.add_node(str(node_names[i]))

    time = -1
    m_current = 0
    edges = defaultdict(lambda: False)

    # add edges
    while m_current &lt; m:
        edge = _np.random.choice(n, size=2, replace=self_loops)
        edge = [node_names[edge[0]], node_names[edge[1]]]
        if not edges[(edge[0], edge[1])]:
            edges[(edge[0], edge[1])] = True
            if not directed:
                edges[(edge[1], edge[0])] = True
            if not temporal:
                m_current += 1
                network.add_edge(edge[0], edge[1])                
            else:
                time += 1
                m_current += 1
                network.add_edge(edge[0], edge[1], time, directed=directed)
    return network


def erdoes_renyi_gnp(n, p, node_names=None, self_loops=True, directed=False, temporal=False):
    &#34;&#34;&#34;
    &#34;&#34;&#34;
    if node_names is None: 
        node_names = [str(x) for x in range(n)]
    assert len(node_names) &gt;= n, &#39;Error: Number of node names not matching degree sequence length&#39;

    if not temporal:
        network = Network(directed=directed)
    else:
        network = TemporalNetwork()

    # make sure that isolated nodes exist
    if not temporal:
        for i in range(n):
            network.add_node(str(node_names[i]))

    time = -1

    # add edges
    for i in range(n):
        for j in range(i+1):
            if i != j or self_loops:                
                if _np.random.rand() &lt;= p:
                    if not temporal:
                        network.add_edge(node_names[i], node_names[j])
                    else:
                        time += 1
                        network.add_edge(node_names[i], node_names[j], time, directed=directed)
    return network


def watts_strogatz(n, p, node_names=None, directed=False):
    &#34;&#34;&#34;
    &#34;&#34;&#34;
    if node_names is None: 
        node_names = [str(x) for x in range(n)]
    assert len(node_names) &gt;= n, &#39;Error: Number of node names not matching degree sequence length&#39;

    raise PathpyNotImplemented(&#39;Watts-Strogatz model is not implemented yet&#39;)


def barabasi_albert(n, n_init, k=1, node_names=None, directed=False, temporal=False):
    &#34;&#34;&#34;
    &#34;&#34;&#34;

    if node_names is None:
        node_names = [str(x) for x in range(n)]
    assert len(node_names) &gt;= n, &#39;Error: Number of node names not matching degree sequence length&#39;
    if not temporal:
        network = Network(directed=directed)
    else:
        network = TemporalNetwork()

    endpoints = []
    time = 0

    # initial network
    for i in range(n_init):
        for j in range(n_init):
            if i &lt; j:
                if not temporal:
                    network.add_edge(str(node_names[i]), str(node_names[j]))
                else:
                    network.add_edge(str(node_names[i]), str(node_names[j]), time, directed=directed)
                endpoints.append(str(node_names[i]))
                endpoints.append(str(node_names[j]))

    for i in range(n_init, n):
        time += 1
        # TODO: for k&gt;1 we can choose different stubs of the same node in one step!
        targets = _np.random.choice(endpoints, size=k, replace=False)
        for t in targets:
            if not temporal:
                network.add_edge(str(node_names[i]), t)
            else:
                network.add_edge(str(node_names[i]), t, time, directed=directed)
            endpoints.append(str(node_names[i]))
            endpoints.append(t)
    return network</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="pathpy.algorithms.random_graphs.barabasi_albert"><code class="name flex">
<span>def <span class="ident">barabasi_albert</span></span>(<span>n, n_init, k=1, node_names=None, directed=False, temporal=False)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def barabasi_albert(n, n_init, k=1, node_names=None, directed=False, temporal=False):
    &#34;&#34;&#34;
    &#34;&#34;&#34;

    if node_names is None:
        node_names = [str(x) for x in range(n)]
    assert len(node_names) &gt;= n, &#39;Error: Number of node names not matching degree sequence length&#39;
    if not temporal:
        network = Network(directed=directed)
    else:
        network = TemporalNetwork()

    endpoints = []
    time = 0

    # initial network
    for i in range(n_init):
        for j in range(n_init):
            if i &lt; j:
                if not temporal:
                    network.add_edge(str(node_names[i]), str(node_names[j]))
                else:
                    network.add_edge(str(node_names[i]), str(node_names[j]), time, directed=directed)
                endpoints.append(str(node_names[i]))
                endpoints.append(str(node_names[j]))

    for i in range(n_init, n):
        time += 1
        # TODO: for k&gt;1 we can choose different stubs of the same node in one step!
        targets = _np.random.choice(endpoints, size=k, replace=False)
        for t in targets:
            if not temporal:
                network.add_edge(str(node_names[i]), t)
            else:
                network.add_edge(str(node_names[i]), t, time, directed=directed)
            endpoints.append(str(node_names[i]))
            endpoints.append(t)
    return network</code></pre>
</details>
</dd>
<dt id="pathpy.algorithms.random_graphs.erdoes_renyi_gnm"><code class="name flex">
<span>def <span class="ident">erdoes_renyi_gnm</span></span>(<span>n, m, node_names=None, self_loops=True, directed=False, temporal=False)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def erdoes_renyi_gnm(n, m, node_names=None, self_loops=True, directed=False, temporal=False):
    &#34;&#34;&#34;
    &#34;&#34;&#34;
    if node_names is None:
        node_names = [str(x) for x in range(n)]

    assert len(node_names) &gt;= n, &#39;Error: Number of node names not matching degree sequence length&#39;

    if not temporal:
        network = Network(directed=directed)
    else:
        network = TemporalNetwork()

    # generate nodes
    if not temporal:
        for i in range(n):
            network.add_node(str(node_names[i]))

    time = -1
    m_current = 0
    edges = defaultdict(lambda: False)

    # add edges
    while m_current &lt; m:
        edge = _np.random.choice(n, size=2, replace=self_loops)
        edge = [node_names[edge[0]], node_names[edge[1]]]
        if not edges[(edge[0], edge[1])]:
            edges[(edge[0], edge[1])] = True
            if not directed:
                edges[(edge[1], edge[0])] = True
            if not temporal:
                m_current += 1
                network.add_edge(edge[0], edge[1])                
            else:
                time += 1
                m_current += 1
                network.add_edge(edge[0], edge[1], time, directed=directed)
    return network</code></pre>
</details>
</dd>
<dt id="pathpy.algorithms.random_graphs.erdoes_renyi_gnp"><code class="name flex">
<span>def <span class="ident">erdoes_renyi_gnp</span></span>(<span>n, p, node_names=None, self_loops=True, directed=False, temporal=False)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def erdoes_renyi_gnp(n, p, node_names=None, self_loops=True, directed=False, temporal=False):
    &#34;&#34;&#34;
    &#34;&#34;&#34;
    if node_names is None: 
        node_names = [str(x) for x in range(n)]
    assert len(node_names) &gt;= n, &#39;Error: Number of node names not matching degree sequence length&#39;

    if not temporal:
        network = Network(directed=directed)
    else:
        network = TemporalNetwork()

    # make sure that isolated nodes exist
    if not temporal:
        for i in range(n):
            network.add_node(str(node_names[i]))

    time = -1

    # add edges
    for i in range(n):
        for j in range(i+1):
            if i != j or self_loops:                
                if _np.random.rand() &lt;= p:
                    if not temporal:
                        network.add_edge(node_names[i], node_names[j])
                    else:
                        time += 1
                        network.add_edge(node_names[i], node_names[j], time, directed=directed)
    return network</code></pre>
</details>
</dd>
<dt id="pathpy.algorithms.random_graphs.is_graphic_sequence"><code class="name flex">
<span>def <span class="ident">is_graphic_sequence</span></span>(<span>degree_sequence, self_loops=False, multi_edges=False)</span>
</code></dt>
<dd>
<section class="desc"><p>Checks whether a degree sequence is graphic, i.e. whether
there exists an <em>undirected</em> graph without self-loops
that has the given degree sequence. A graphic degree sequence is the
precondition to apply the Molloy-Reed random graph generation.</p>
<p>Note: this function does not support multi-edge networks with no self-loops.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>degree_sequence</code></strong> :&ensp;<code>list</code> or <code>tuple</code></dt>
<dd>the degree sequence for which to test the graphic property</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>bool</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def is_graphic_sequence(degree_sequence, self_loops=False, multi_edges=False):
    r&#34;&#34;&#34;Checks whether a degree sequence is graphic, i.e. whether
    there exists an *undirected* graph without self-loops
    that has the given degree sequence. A graphic degree sequence is the
    precondition to apply the Molloy-Reed random graph generation.

    Note: this function does not support multi-edge networks with no self-loops.

    Parameters
    ----------
    degree_sequence: list or tuple
        the degree sequence for which to test the graphic property

    Returns
    -------
    bool
    &#34;&#34;&#34;
    assert not (not self_loops and multi_edges), &#39;Networks with multi_edges and no self_loops are not supported&#39;
    S = sum(degree_sequence)
    n = len(degree_sequence)

    # the sum of degrees must always be even (assuming self-loops are counted with degree of two)
    if S%2 != 0:
        return False

    # if multi-edges are allowed we are done
    if multi_edges:
        return True

    # use Behzad and Chartrand 1967, which shows that in a graphic degree
    # sequence at least one degree must occur twice (holds for networks without self_loops)
    if not self_loops and len(set(degree_sequence)) == len(degree_sequence):
        return False

    ordered_sequence = sorted(degree_sequence, reverse=True)

    # check necessary and sufficient condition given by Erdös and Gallai (1960)
    # see http://mathworld.wolfram.com/GraphicSequence.html
    # for networks with self-loops, we check the condition for all r&lt;=n
    # for networks without self-loops, we check the condition for all r&lt;=n-1

    if self_loops:
        max_r = n+1
    else:
        max_r = n

    for r in range(0, max_r):
        M = 0
        S = 0
        for i in range(0, r):
            S += ordered_sequence[i]
        for i in range(r, n):
            M += min(r+1, ordered_sequence[i])
        if S &gt; r * (r+1) + M:
            return False

    return True</code></pre>
</details>
</dd>
<dt id="pathpy.algorithms.random_graphs.molloy_reed"><code class="name flex">
<span>def <span class="ident">molloy_reed</span></span>(<span>degree_sequence, node_names=None, self_loops=True, multi_edges=False)</span>
</code></dt>
<dd>
<section class="desc"><p>Generates a random undirected network with a given degree sequence.
The generated network is guaranteed to have the given degree sequence.
Multiple edges are forbidden in the network generation. Raises an exception
if the given degree sequence is not graphic, i.e. if no possible simple
graph exisits with the desired degree sequence.</p>
<dl>
<dt><strong><code>Note</code></strong> :&ensp;<code>this</code> <code>function</code> <code>does</code> <code>not</code> <code>support</code> <code>the</code> <code>generation</code> of <code>multi</code>-<code>edge</code> <code>networks</code></dt>
<dd>&nbsp;</dd>
</dl>
<p>with no self-loops.</p>
<h2 id="parameters">Parameters:</h2>
<dl>
<dt><strong><code>degree_sequence</code></strong> :&ensp;<code>list</code> or <code>tuple</code></dt>
<dd>The degree sequence of the randomly generated network. The degree
sequence must have at least two entries. The sequence must be graphic,
or an exception will be raised.</dd>
<dt><strong><code>node_names</code></strong> :&ensp;<code>list</code> or <code>tuple</code></dt>
<dd>Node names to be used in the network creation. If None (default)
nodes will be numbered from 0 to n-1, where n is the length of
the degree sequence.</dd>
<dt><strong><code>self_loops</code></strong> :&ensp;<code>bol</code></dt>
<dd>Whether or not to allow the generation of self_loops. Default is True.</dd>
</dl></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def molloy_reed(degree_sequence, node_names=None, self_loops=True, multi_edges=False):
    &#34;&#34;&#34;
    Generates a random undirected network with a given degree sequence.
    The generated network is guaranteed to have the given degree sequence.
    Multiple edges are forbidden in the network generation. Raises an exception
    if the given degree sequence is not graphic, i.e. if no possible simple
    graph exisits with the desired degree sequence.

    Note: this function does not support the generation of multi-edge networks
    with no self-loops.

    Parameters:
    -----------
    degree_sequence: list or tuple
        The degree sequence of the randomly generated network. The degree
        sequence must have at least two entries. The sequence must be graphic,
        or an exception will be raised.
    node_names: list or tuple
        Node names to be used in the network creation. If None (default)
        nodes will be numbered from 0 to n-1, where n is the length of
        the degree sequence.
    self_loops: bol
        Whether or not to allow the generation of self_loops. Default is True.
    &#34;&#34;&#34;    

    assert is_graphic_sequence(degree_sequence, self_loops=self_loops, multi_edges=multi_edges), &#39;Error: degree sequence is not graphic&#39;

    n = len(degree_sequence)

    if node_names is None:
        node_names = [str(x) for x in range(n)]
    assert len(node_names) &gt;= n, &#39;Error: Number of node names not matching degree sequence length&#39;

    network = Network(directed=False)

    # generate a list with node stubs
    stubs = []
    for i in range(n):
        for j in range(degree_sequence[i]):
            stubs.append(str(node_names[i]))

    while len(stubs) &gt; 1:
        random_nodes = _np.random.choice(stubs, size=2, replace=False)
        (v, w) = (random_nodes[0], random_nodes[1])
        if (multi_edges or (v, w) not in network.edges) and (self_loops or v != w):
            weight = 1.0
            if (v, w) in network.edges:
                weight += network.edges[(v, w)][&#39;weight&#39;]
            network.add_edge(v, w, weight=weight)
            stubs.remove(v)
            if v != w: # ensures that self-loops are counted as degree 1
                stubs.remove(w)
        elif network.ecount() &gt; 0: # randomly remove edge
            edges = list(network.edges)
            edge = edges[_np.random.choice(len(edges))]
            network.remove_edge(edge[0], edge[1])
            stubs.append(edge[0])
            stubs.append(edge[1])
    return network</code></pre>
</details>
</dd>
<dt id="pathpy.algorithms.random_graphs.random_k_regular"><code class="name flex">
<span>def <span class="ident">random_k_regular</span></span>(<span>n, k, self_loops=True, node_names=None)</span>
</code></dt>
<dd>
<section class="desc"><p>Generates an undirected random k-regular network, i.e. a random
network where all nodes have exactly degree k. A call to this
function is equivalent to generating a random network with a
given degree sequence [k]*n.</p>
<h2 id="parameters">Parameters:</h2>
<dl>
<dt><strong><code>n</code></strong> :&ensp;<code>int</code></dt>
<dd>The number of nodes in the generated network.</dd>
<dt><strong><code>k</code></strong> :&ensp;<code>int</code></dt>
<dd>The degree of all nodes</dd>
<dt><strong><code>self_loops</code></strong> :&ensp;<code>bool</code></dt>
<dd>Whether or not to allow self_loops in the network generation.
Default is True.</dd>
<dt><strong><code>node_names</code></strong> :&ensp;<code>list</code> or <code>sequence</code></dt>
<dd>Node names to be used in the network creation. If None (default)
nodes will be numbered from 0 to n-1.</dd>
</dl></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def random_k_regular(n, k, self_loops=True, node_names=None):
    &#34;&#34;&#34;
    Generates an undirected random k-regular network, i.e. a random
    network where all nodes have exactly degree k. A call to this
    function is equivalent to generating a random network with a 
    given degree sequence [k]*n.

    Parameters:
    -----------
    n: int
        The number of nodes in the generated network.
    k: int
        The degree of all nodes
    self_loops: bool
        Whether or not to allow self_loops in the network generation. 
        Default is True.
    node_names: list or sequence
        Node names to be used in the network creation. If None (default)
        nodes will be numbered from 0 to n-1.
    &#34;&#34;&#34;
    assert n*k%2 == 0, &#39;Error: parameters lead to non-graphic degree sequence.&#39;
    return molloy_reed([k]*n, node_names=node_names, self_loops=self_loops)</code></pre>
</details>
</dd>
<dt id="pathpy.algorithms.random_graphs.watts_strogatz"><code class="name flex">
<span>def <span class="ident">watts_strogatz</span></span>(<span>n, p, node_names=None, directed=False)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def watts_strogatz(n, p, node_names=None, directed=False):
    &#34;&#34;&#34;
    &#34;&#34;&#34;
    if node_names is None: 
        node_names = [str(x) for x in range(n)]
    assert len(node_names) &gt;= n, &#39;Error: Number of node names not matching degree sequence length&#39;

    raise PathpyNotImplemented(&#39;Watts-Strogatz model is not implemented yet&#39;)</code></pre>
</details>
</dd>
</dl>
</section>
<section>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="pathpy.algorithms" href="index.html">pathpy.algorithms</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="two-column">
<li><code><a title="pathpy.algorithms.random_graphs.barabasi_albert" href="#pathpy.algorithms.random_graphs.barabasi_albert">barabasi_albert</a></code></li>
<li><code><a title="pathpy.algorithms.random_graphs.erdoes_renyi_gnm" href="#pathpy.algorithms.random_graphs.erdoes_renyi_gnm">erdoes_renyi_gnm</a></code></li>
<li><code><a title="pathpy.algorithms.random_graphs.erdoes_renyi_gnp" href="#pathpy.algorithms.random_graphs.erdoes_renyi_gnp">erdoes_renyi_gnp</a></code></li>
<li><code><a title="pathpy.algorithms.random_graphs.is_graphic_sequence" href="#pathpy.algorithms.random_graphs.is_graphic_sequence">is_graphic_sequence</a></code></li>
<li><code><a title="pathpy.algorithms.random_graphs.molloy_reed" href="#pathpy.algorithms.random_graphs.molloy_reed">molloy_reed</a></code></li>
<li><code><a title="pathpy.algorithms.random_graphs.random_k_regular" href="#pathpy.algorithms.random_graphs.random_k_regular">random_k_regular</a></code></li>
<li><code><a title="pathpy.algorithms.random_graphs.watts_strogatz" href="#pathpy.algorithms.random_graphs.watts_strogatz">watts_strogatz</a></code></li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.5.3</a>.</p>
</footer>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
<script>hljs.initHighlightingOnLoad()</script>
</body>
</html>