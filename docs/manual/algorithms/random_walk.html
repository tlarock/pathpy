<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.5.3" />
<title>pathpy.algorithms.random_walk API documentation</title>
<meta name="description" content="Algorithms to calculate shortest paths and distances in higher-order networks and paths." />
<link href='https://cdnjs.cloudflare.com/ajax/libs/normalize/8.0.0/normalize.min.css' rel='stylesheet'>
<link href='https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/8.0.0/sanitize.min.css' rel='stylesheet'>
<link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/github.min.css" rel="stylesheet">
<style>.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{font-weight:bold}#index h4 + ul{margin-bottom:.6em}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.name small{font-weight:normal}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase;cursor:pointer}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}.admonition{padding:.1em .5em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title"><code>pathpy.algorithms.random_walk</code> module</h1>
</header>
<section id="section-intro">
<p>Algorithms to calculate shortest paths and distances in higher-order networks and paths.</p>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">&#34;&#34;&#34;
Algorithms to calculate shortest paths and distances in higher-order networks and paths.
&#34;&#34;&#34;
# -*- coding: utf-8 -*-

#    pathpy is an OpenSource python package for the analysis of time series data
#    on networks using higher- and multi order graphical models.
#
#    Copyright (C) 2016-2018 Ingo Scholtes, ETH Zürich/Universität Zürich
#
#    This program is free software: you can redistribute it and/or modify
#    it under the terms of the GNU Affero General Public License as published
#    by the Free Software Foundation, either version 3 of the License, or
#    (at your option) any later version.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU Affero General Public License for more details.
#
#    You should have received a copy of the GNU Affero General Public License
#    along with this program. If not, see &lt;http://www.gnu.org/licenses/&gt;.
#
#    Contact the developer:
#
#    E-mail: scholtes@ifi.uzh.ch
#    Web:    http://www.ingoscholtes.net
from functools import singledispatch
from collections import defaultdict

from pathpy.utils import Log, Severity
from pathpy.utils import PathpyNotImplemented
from pathpy.classes import TemporalNetwork
from pathpy.classes import Network
from pathpy.classes import HigherOrderNetwork
import numpy as _np

__all__ = [&#39;generate_walk&#39;]

@singledispatch
def generate_walk(network, l=100, start_node=None):
    &#34;&#34;&#34;
    Generate a random walk trajectory of a given length, based on
    a weighted/directed/undirected network, temporal network, or
    higher-order network.

    Parameters:
    -----------
    network: Network, TemporalNetwork, HigherOrderNetwork
        The temporal, first-order, or higher-order network, which
        will be used to randomly generate a walk through a network.
    l: int
        The (maximum) length of the walk to be generated. If a node
        with out-degree zero is encountered, the walk is terminated
        even if l has not been reached.
    start_node: str
        The (higher-order) node in which the random walk will be started.
        Default is None, in which case a random start node will be chosen.
    &#34;&#34;&#34;
    T = network.transition_matrix().todense().transpose()
    idx_map = network.node_to_name_map()
    nodes = _np.array([v for v in network.nodes])

    itinerary = []

    if start_node is None:
        start_node = _np.random.choice(nodes)

    # choose random start node
    itinerary.append(start_node)
    for j in range(l):
        # get transition probability vector T[idx -&gt;  . ]
        prob = _np.array(T[idx_map[itinerary[-1]], :])[0, :]
        nz = prob.nonzero()[0]
        # make one random transition
        if nz.shape[0] &gt; 0:
            next_node = _np.random.choice(a=nodes[nz], p=prob[nz])
            # add node to path
            itinerary.append(next_node)
        else: # no neighbor
            break
    return itinerary


@generate_walk.register(HigherOrderNetwork)
def _temporal_walk(higher_order_net, l=100, start_node=None):

    T = higher_order_net.transition_matrix().todense().transpose()
    idx_map = higher_order_net.node_to_name_map()
    nodes = _np.array([v for v in higher_order_net.nodes])

    itinerary = []

    if start_node is None:
        start_node = _np.random.choice(nodes)
    last = start_node

    # choose random start node
    for x in higher_order_net.higher_order_node_to_path(start_node):
        itinerary.append(x)
    for j in range(l):
        # get transition probability vector T[idx -&gt;  . ]
        prob = _np.array(T[idx_map[last], :])[0, :]
        nz = prob.nonzero()[0]
        # make one random transition
        if nz.shape[0] &gt; 0:
            next_node = _np.random.choice(a=nodes[nz], p=prob[nz])
            # add node to path
            itinerary.append(higher_order_net.higher_order_node_to_path(next_node)[-1])
            last = next_node
        else: # no neighbor
            break
    return itinerary


@generate_walk.register(TemporalNetwork)
def _temporal_walk(tempnet, l=100, start_node=None):

    itinerary = []
    if start_node is None:
        current_node = _np.random.choice(tempnet.nodes)
    else:
        current_node = start_node
    itinerary.append(current_node)
    steps = 0
    for t in tempnet.ordered_times:
        prev_node = current_node
        # find possible targets in time t
        targets = set()
        for (v, w, time) in tempnet.time[t]:
            if v == current_node:
               targets.add(w)
        # move to random target
        if targets:
            current_node = _np.random.choice(list(targets))
            steps += 1
        # add currently visited node
        if current_node != prev_node:
            itinerary.append(current_node)
        if steps == l:
            break
    return itinerary</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="pathpy.algorithms.random_walk.generate_walk"><code class="name flex">
<span>def <span class="ident">generate_walk</span></span>(<span>network, l=100, start_node=None)</span>
</code></dt>
<dd>
<section class="desc"><p>Generate a random walk trajectory of a given length, based on
a weighted/directed/undirected network, temporal network, or
higher-order network.</p>
<h2 id="parameters">Parameters:</h2>
<dl>
<dt><strong><code>network</code></strong> :&ensp;<code>Network</code>, <code>TemporalNetwork</code>, <code>HigherOrderNetwork</code></dt>
<dd>The temporal, first-order, or higher-order network, which
will be used to randomly generate a walk through a network.</dd>
<dt><strong><code>l</code></strong> :&ensp;<code>int</code></dt>
<dd>The (maximum) length of the walk to be generated. If a node
with out-degree zero is encountered, the walk is terminated
even if l has not been reached.</dd>
<dt><strong><code>start_node</code></strong> :&ensp;<code>str</code></dt>
<dd>The (higher-order) node in which the random walk will be started.
Default is None, in which case a random start node will be chosen.</dd>
</dl></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">@singledispatch
def generate_walk(network, l=100, start_node=None):
    &#34;&#34;&#34;
    Generate a random walk trajectory of a given length, based on
    a weighted/directed/undirected network, temporal network, or
    higher-order network.

    Parameters:
    -----------
    network: Network, TemporalNetwork, HigherOrderNetwork
        The temporal, first-order, or higher-order network, which
        will be used to randomly generate a walk through a network.
    l: int
        The (maximum) length of the walk to be generated. If a node
        with out-degree zero is encountered, the walk is terminated
        even if l has not been reached.
    start_node: str
        The (higher-order) node in which the random walk will be started.
        Default is None, in which case a random start node will be chosen.
    &#34;&#34;&#34;
    T = network.transition_matrix().todense().transpose()
    idx_map = network.node_to_name_map()
    nodes = _np.array([v for v in network.nodes])

    itinerary = []

    if start_node is None:
        start_node = _np.random.choice(nodes)

    # choose random start node
    itinerary.append(start_node)
    for j in range(l):
        # get transition probability vector T[idx -&gt;  . ]
        prob = _np.array(T[idx_map[itinerary[-1]], :])[0, :]
        nz = prob.nonzero()[0]
        # make one random transition
        if nz.shape[0] &gt; 0:
            next_node = _np.random.choice(a=nodes[nz], p=prob[nz])
            # add node to path
            itinerary.append(next_node)
        else: # no neighbor
            break
    return itinerary</code></pre>
</details>
</dd>
</dl>
</section>
<section>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="pathpy.algorithms" href="index.html">pathpy.algorithms</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="pathpy.algorithms.random_walk.generate_walk" href="#pathpy.algorithms.random_walk.generate_walk">generate_walk</a></code></li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.5.3</a>.</p>
</footer>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
<script>hljs.initHighlightingOnLoad()</script>
</body>
</html>